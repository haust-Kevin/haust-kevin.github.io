{
    "version": "https://jsonfeed.org/version/1",
    "title": "沉思录",
    "subtitle": "古之立大事者，不惟有超世之才，亦必有坚忍不拔之志",
    "icon": "https://haust-kevin.github.io/images/favicon.ico",
    "description": "思考未知，追求卓越",
    "home_page_url": "https://haust-kevin.github.io",
    "items": [
        {
            "id": "https://haust-kevin.github.io/2025/01/19/2025-01-rust-init-env/",
            "url": "https://haust-kevin.github.io/2025/01/19/2025-01-rust-init-env/",
            "title": "Rust：环境搭建",
            "date_published": "2025-01-19T12:29:28.000Z",
            "content_html": "<div class=\"note primary\">\n<p>本篇文章指导搭建 Rust 开发环境。通过本文学习，你可以使用集成 IDE 进行 Rust 编程。本文包括：</p>\n<ol>\n<li>安装 rustup 工具链</li>\n<li>安装 RustRover 集成 IDE</li>\n</ol>\n</div>\n<h2 id=\"安装-rust\"><a class=\"anchor\" href=\"#安装-rust\">#</a> 安装 Rust</h2>\n<h3 id=\"安装-rustup-管理工具链\"><a class=\"anchor\" href=\"#安装-rustup-管理工具链\">#</a> 安装 rustup 管理工具链</h3>\n<p>在进行 Rust 开发前你需要安装 Rust 开发必备的工具链。<br />\n下载地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVzdC1sYW5nLm9yZy96aC1DTi90b29scy9pbnN0YWxs\">rustup-init</span><br />\n 下载后，执行文件  <code>rustup-init.exe</code> ，在弹出的窗口输入  <code>1</code>  并按回车。等待脚本执行完即可。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master/images/20250119204327593.png\" alt=\"图片\" /></p>\n<h3 id=\"安装-rustrover\"><a class=\"anchor\" href=\"#安装-rustrover\">#</a> 安装 RustRover</h3>\n<p>工欲善其事必先利其器，你需要使用专业的 IDE 进行代码开发，否则使用 Rust 编程是非常痛苦的事，Rust 最难的就是通过编译，没有 IDE 的静态检查，你将在编译上浪费许多时间。可以使用 vscode 安装插件达到 IDE 的效果，但我推荐使用 RustRover。<br />\n下载地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9ydXN0Lw==\">Jetbrains RustRover</span><br />\n 选择个人非商用即可使用。</p>\n<h2 id=\"enjoy-rust\"><a class=\"anchor\" href=\"#enjoy-rust\">#</a> Enjoy Rust</h2>\n",
            "tags": [
                "环境搭建",
                "Rust",
                "RustRover"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2024/04/27/2024-04-leetcode-permutation-sequence/",
            "url": "https://haust-kevin.github.io/2024/04/27/2024-04-leetcode-permutation-sequence/",
            "title": "LeetCode：60. 排列序列",
            "date_published": "2024-04-27T14:03:28.000Z",
            "content_html": "<p>原题链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbi1zZXF1ZW5jZS9kZXNjcmlwdGlvbi8=\">60. 排列序列</span><br />\n难度分类：<font color=red>Hard</font></p>\n<h2 id=\"problem\"><a class=\"anchor\" href=\"#problem\">#</a> Problem</h2>\n<p>给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。</p>\n<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时，所有排列如下：</p>\n<p>&quot;123&quot;<br />\n&quot;132&quot;<br />\n&quot;213&quot;<br />\n&quot;231&quot;<br />\n&quot;312&quot;<br />\n&quot;321&quot;<br />\n 给定 n 和 k，返回第 k 个排列。</p>\n<p><strong>Examples</strong></p>\n<ul>\n<li>\n<p>示例 1：<br />\n输入：n = 3, k = 3<br />\n 输出：&quot;213&quot;</p>\n</li>\n<li>\n<p>示例 2：<br />\n输入：n = 4, k = 9<br />\n 输出：&quot;2314&quot;</p>\n</li>\n<li>\n<p>示例 3：<br />\n输入：n = 3, k = 1<br />\n 输出：&quot;123&quot;</p>\n</li>\n</ul>\n<h2 id=\"approach\"><a class=\"anchor\" href=\"#approach\">#</a> Approach</h2>\n<p>例如：  <code>n = 6, k = 373</code> <br />\n 初始化数组  <code>remain = [1, 2, 3, 4, 5, 6]</code> ;<br />\n 首先应该明白，以 <strong>1</strong> 开头的全排列有  <code>5!</code>  个，以 <strong>2</strong> 开头的全排列有  <code>5!</code>  个 …… 共  <code>5! ∗ 6 = 6!</code>  个；</p>\n<ol>\n<li>故 k = 373 时，全排列的第一个数字应该是  <code>remain[k / 5!] = 4</code> ;</li>\n<li>数组删除  <code>4</code> , 此时  <code>remain = [1, 2, 3, 5, 6]</code> ;  <code>k = k % 5! = 12</code> ;</li>\n<li>接下来就是在  <code>remain</code>  中找第 12 个全排列，重复 1，2 步即可 。</li>\n</ol>\n<h2 id=\"code\"><a class=\"anchor\" href=\"#code\">#</a> Code</h2>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getPermutation</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> remain <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> ans <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        k<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            x <span class=\"token operator\">*=</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            remain<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>remain<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            x <span class=\"token operator\">/=</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> k <span class=\"token operator\">/</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            ans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>remain<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            remain<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            k <span class=\"token operator\">%=</span> x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token class-name\">String</span> ret <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> ans<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            ret <span class=\"token operator\">+=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "算法题解",
                "LeetCode",
                "algorithm",
                "leetcode",
                "hard",
                "数学"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/11/03/2023-11-interview-middleware-mq/",
            "url": "https://haust-kevin.github.io/2023/11/03/2023-11-interview-middleware-mq/",
            "title": "面试指北：消息队列",
            "date_published": "2023-11-03T11:58:57.000Z",
            "content_html": "<h2 id=\"mq\"><a class=\"anchor\" href=\"#mq\">#</a> MQ</h2>\n<h3 id=\"常见-mq-模型\"><a class=\"anchor\" href=\"#常见-mq-模型\">#</a> 常见 MQ 模型</h3>\n<p><strong>队列模型</strong><br />\n最简单的消息模型，队列模式，用阻塞队列实现的生产者消费者模式，也可以看作一个队列模型的消息队列。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311051512755.png\" alt=\"\" /><br />\n<strong>发布 - 订阅模型</strong><br />\n队列模式也可以有多个生产者消费者，但是同一个消息只能被一个消费者消费，为了解决这个为题，演化出了另一种消息模型 ** 发布 - 订阅模型（Publish-Subscribe Pattern）** 也被称为主题模型。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311051515770.png\" alt=\"\" /><br />\n在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先 “订阅主题”。每个订阅者都可以接收到主题的所有消息。</p>\n<h3 id=\"kafka\"><a class=\"anchor\" href=\"#kafka\">#</a> Kafka</h3>\n<p><strong>消息模型</strong><br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311051521839.png\" alt=\"\" /><br />\n<strong>服务架构</strong><br />\n<strong> partition</strong>：kafka Topic 可以划分为多个 partition，分布在不同的 Broker 上，天然分布式，每个 patition 可以设置副本，其中主 partition 为 leader，副本 partition 为 follower，follower 和 leader 在不同的机器，消息的接收和发送都是 leader 负责的，follower partition 会从 leader 同步数据，如果 leader 所在的 borker 挂了，会从 follower 中选举一个成为 leader，高可用。</p>\n<p><strong>Consumer Group</strong>：在 kafka 的 Topic 的订阅单位也是 Consumer Group，每个消费组可以收到完整的消息，但是同一个分区的数据只能被消费者组中的某一个消费者消费，分区和消费者关系是多对一。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311051518428.png\" alt=\"\" /></p>\n<h3 id=\"mq-的作用\"><a class=\"anchor\" href=\"#mq-的作用\">#</a> MQ 的作用</h3>\n<ul>\n<li><strong>解耦</strong>：将系统按照不同的业务功能拆分出来，消息生产者只管把消息发布到 MQ 中而不用管谁来取，消息消费者只管从 MQ 中取消息而不管是谁发布的。消息生产者和消费者都不知道对方的存在；</li>\n<li><strong>异步</strong>：主流程只需要完成业务的核心功能；对于业务非核心功能，将消息放入到消息队列之中进行异步处理，减少请求的等待，提高系统的总体性能；</li>\n<li><strong>削峰 / 限流</strong>：将所有请求都写到消息队列中，消费服务器按照自身能够处理的请求数从队列中拿到请求，防止请求并发过高将系统搞崩溃；</li>\n</ul>\n<h3 id=\"mq-的缺点\"><a class=\"anchor\" href=\"#mq-的缺点\">#</a> MQ 的缺点</h3>\n<ul>\n<li><strong>系统可用性降低</strong>：系统引用的外部依赖越多，越容易挂掉，如果 MQ 服务器挂掉，那么可能会导致整套系统崩溃。这时就要考虑如何保证消息队列的高可用了。</li>\n<li><strong>系统复杂度提高</strong>：加入消息队列之后，需要保证消息没有重复消费、如何处理消息丢失的情况、如何保证消息传递的有序性等问题。</li>\n<li><strong>数据一致性问题</strong>：A 系统处理完了直接返回成功了，使用者都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，就会导致数据不一致了。</li>\n</ul>\n<h3 id=\"常见-mq-的对比\"><a class=\"anchor\" href=\"#常见-mq-的对比\">#</a> 常见 MQ 的对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单机吞吐量</td>\n<td>万级，比 RocketMQ、Kafka 低一个数量级</td>\n<td>同 ActiveMQ</td>\n<td>10 万级，支撑高吞吐</td>\n<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>\n</tr>\n<tr>\n<td>topic 数量对吞吐量的影响</td>\n<td colspan=\"2\"></td>\n<td>topic 可以达到几百 / 几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>\n<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms 级</td>\n<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>\n<td>ms 级</td>\n<td>延迟在 ms 级以内</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高，基于主从架构实现高可用</td>\n<td>同 ActiveMQ</td>\n<td>非常高，分布式架构</td>\n<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>有较低的概率丢失数据</td>\n<td>基本不丢</td>\n<td>经过参数优化配置，可以做到 0 丢失</td>\n<td>同 RocketMQ</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>MQ 领域的功能极其完备</td>\n<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>\n<td>MQ 功能较为完善，还是分布式的，扩展性好</td>\n<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何保证消息不被重复消费\"><a class=\"anchor\" href=\"#如何保证消息不被重复消费\">#</a> 如何保证消息不被重复消费</h3>\n<p>因为消息队列的服务质量是 <strong>At least once</strong> ，因此消息队列无法保证消息不重复，因此消费重复的问题得由 Consumer 端来解决。<br />\n一般采用<strong>幂等性</strong>解决重复消息问题。所以「如何保证消息不被重复消费？」就转变为「如何保证消费者的幂等性？」<br />\n<strong>那么如何保证幂等性呢？</strong></p>\n<ol>\n<li>写数据时，先根据主键查一下这条数据是否存在，如果已经存在则 update；</li>\n<li>数据库的唯一键约束也可以保证不会重复插入多条，因为重复插入多条只会报错，不会导致数据库中出现脏数据；</li>\n<li>如果是写 redis，就没有问题，因为 set 操作是天然幂等性的。</li>\n</ol>\n<h3 id=\"如何保证消息不丢失进行可靠性传输\"><a class=\"anchor\" href=\"#如何保证消息不丢失进行可靠性传输\">#</a> 如何保证消息不丢失，进行可靠性传输</h3>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311042311197.png\" alt=\"\" /><br />\n可以看到一共有三个阶段，分别是<strong>生产消息</strong>、<strong>存储消息</strong>和<strong>消费消息</strong>。我们从这三个阶段分别入手来看看如何确保消息不会丢失。</p>\n<p><strong>生产消息</strong><br />\n生产者发送消息至 Broker，需要处理 Broker 的响应，不论是同步还是异步发送消息，同步和异步回调都需要<strong>做好 try-catch</strong>，妥善的处理响应，如果 Broker 返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等。<br />\n这样就能保证在生产消息阶段消息不会丢失。</p>\n<p><strong>存储消息</strong><br />\n存储消息阶段需要<strong>在消息刷盘之后再给生产者响应</strong>，假设消息写入缓存中就返回响应，那么机器突然断电这消息就没了，而生产者以为已经发送成功了。<br />\n如果 Broker 是集群部署，有多副本机制，即消息不仅仅要写入当前 Broker, 还需要写入副本机中。那配置成至少写入两台机子后再给生产者响应。这样基本上就能保证存储的可靠了。</p>\n<p><strong>消费消息</strong><br />\n这里经常会有同学犯错，有些同学当消费者拿到消息之后直接存入内存队列中就直接返回给 Broker 消费成功，这是不对的。<br />\n你需要考虑拿到消息放在内存之后消费者就宕机了怎么办。所以我们应该<strong>在消费者真正执行完业务逻辑之后，再发送给 Broker 消费成功</strong>，这才是真正的消费了。<br />\n所以只要我们在消息业务逻辑处理完成之后再给 Broker 响应，那么消费阶段消息就不会丢失。</p>\n<p><strong>小结一下</strong><br />\n可以看出，保证消息的可靠性需要三方配合。</p>\n<ul>\n<li>生产者需要处理好 Broker 的响应，出错情况下利用重试、报警等手段。</li>\n<li>Broker 需要控制响应的时机，单机情况下是消息刷盘后返回响应，集群多副本情况下，即发送至两个副本及以上的情况下再返回响应。</li>\n<li>消费者需要在执行完真正的业务逻辑之后再返回响应给 Broker。</li>\n</ul>\n<h3 id=\"如何保证消息的有序性\"><a class=\"anchor\" href=\"#如何保证消息的有序性\">#</a> 如何保证消息的有序性</h3>\n<p>有序性分：全局有序和部分有序。<br />\n<strong>全局有序</strong><br />\n如果要保证消息的全局有序，首先只能由一个生产者往 Topic 发送消息，并且一个 Topic 内部只能有一个队列（分区）。消费者也必须是单线程消费这个队列。这样的消息就是全局有序的！<br />\n不过一般情况下我们都不需要全局有序，即使是同步 MySQL Binlog 也只需要保证单表消息有序即可。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311042348158.png\" alt=\"\" /></p>\n<p><strong>部分有序</strong><br />\n因此绝大部分的有序需求是部分有序，部分有序我们就可以将 Topic 内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中，然后每个队列对应一个单线程处理的消费者。这样即完成了部分有序的需求，又可以通过队列数量的并发来提高消息处理效率。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311050007730.png\" alt=\"\" /></p>\n<h3 id=\"如何处理消息堆积情况\"><a class=\"anchor\" href=\"#如何处理消息堆积情况\">#</a> 如何处理消息堆积情况</h3>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311050015622.jpg\" alt=\"\" /></p>\n<p>新建一个临时的 Topic，设置为 <code>5*X</code>  个 Partition。<br />\n原 Consumer 不再处理业务逻辑了，只负责搬运，把消息放到临时 Topic 中。<br />\n这  <code>5*X</code>  个 Partition 可以有 <code>5*X</code>  个 Consumer 了，它们来处理原来的业务逻辑。<br />\n这  <code>5*X</code>  个 Consumer 每秒一共能处理原来五倍数量的消息了，这样就可以快速处理完积压的消息。<br />\n当处理完消息积压后，将原来的 Topic 分区增加到适当数量，把整体结构恢复为原来的形式。</p>\n",
            "tags": [
                "面试指北",
                "中间件",
                "八股文",
                "消息队列",
                "Kafka"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/11/01/2023-11-interview-web-spring/",
            "url": "https://haust-kevin.github.io/2023/11/01/2023-11-interview-web-spring/",
            "title": "面试指北：Spring",
            "date_published": "2023-11-01T10:02:28.000Z",
            "content_html": "<h2 id=\"framework\"><a class=\"anchor\" href=\"#framework\">#</a> Framework</h2>\n<p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test 等 6 个模块中。 以下是 Spring 5 的模块结构图：<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311021759403.png\" alt=\"\" /></p>\n<ul>\n<li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li>\n<li>spring beans：提供了 BeanFactory，是工厂模式的一个经典实现，Spring 将管理对象称为 Bean。</li>\n<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>\n<li>spring jdbc：提供了一个 JDBC 的抽象层，消除了烦琐的 JDBC 编码和数据库厂商特有的错误代码解析， 用于简化 JDBC。</li>\n<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>\n<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>\n<li>spring test：主要为测试提供支持的，支持使用 JUnit 或 TestNG 对 Spring 组件进行单元测试和集成测试。</li>\n</ul>\n<h2 id=\"aop\"><a class=\"anchor\" href=\"#aop\">#</a> AOP</h2>\n<p>AOP：Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。</p>\n<p>AOP 有两种实现方式：静态代理和动态代理。</p>\n<h3 id=\"aop-实现方式\"><a class=\"anchor\" href=\"#aop-实现方式\">#</a> AOP 实现方式</h3>\n<p><strong>静态代理</strong><br />\n静态代理：代理类在编译阶段生成，在编译阶段将通知织入 Java 字节码中，也称编译时增强。AspectJ 使用的是静态代理。</p>\n<p>缺点：代理对象需要与目标对象实现一样的接口，并且实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。</p>\n<p><strong>动态代理</strong></p>\n<p>动态代理：代理类在程序运行时创建，AOP 框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类。</p>\n<h3 id=\"spring-aop\"><a class=\"anchor\" href=\"#spring-aop\">#</a> Spring AOP</h3>\n<p>Spring 的 AOP 实现原理其实很简单，就是通过动态代理实现的。如果我们为 Spring 的某个 bean 配置了切面，那么 Spring 在创建这个 bean 的时候，实际上创建的是这个 bean 的一个代理对象，我们后续对 bean 中方法的调用，实际上调用的是代理类重写的代理方法。而 Spring 的 AOP 使用了两种动态代理，分别是 JDK 的动态代理，以及 CGLib 的动态代理。</p>\n<p>如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP，也可以强制使用 CGLIB 实现 AOP。<br />\n如果目标对象没有实现了接口，必须采用 CGLIB 库。</p>\n<h4 id=\"jdk-动态代理\"><a class=\"anchor\" href=\"#jdk-动态代理\">#</a> JDK 动态代理</h4>\n<p>如果目标类实现了接口，Spring AOP 会选择使用 JDK 动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类。<br />\n<strong>缺点</strong>：目标类必须有实现的接口。如果某个类没有实现接口，那么这个类就不能用 JDK 动态代理。</p>\n<h4 id=\"cglib-动态代理\"><a class=\"anchor\" href=\"#cglib-动态代理\">#</a> CGLIB 动态代理</h4>\n<p>通过继承实现。如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library）可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。</p>\n<p>CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p>\n<p><strong>优点</strong>：目标类不需要实现特定的接口，更加灵活。</p>\n<h3 id=\"spring-aop-相关术语\"><a class=\"anchor\" href=\"#spring-aop-相关术语\">#</a> Spring AOP 相关术语</h3>\n<ul>\n<li><strong>切面（Aspect）</strong>：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。</li>\n<li><strong>连接点（Join point）</strong>：指方法，在 Spring AOP 中，一个连接点总是代表一个方法的执行。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</li>\n<li><strong>通知（Advice）</strong>：在 AOP 术语中，切面的工作被称为通知。</li>\n<li><strong>切入点（Pointcut）</strong>：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</li>\n<li><strong>引入（Introduction）</strong>：引入允许我们向现有类添加新方法或属性。</li>\n<li><strong>目标对象（Target Object）</strong>： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。</li>\n<li><strong>织入（Weaving）</strong>：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有以下时间点可以进行织入：\n<ul>\n<li>编译期：切面在目标类编译时被织入。AspectJ 的织入编译器是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5 的加载时织入就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。SpringAOP 就是以这种方式织入切面。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"spring-aop-通知类型\"><a class=\"anchor\" href=\"#spring-aop-通知类型\">#</a> Spring AOP 通知类型</h3>\n<ul>\n<li><strong>前置通知（Before）</strong>：在目标方法被调用之前调用通知功能；</li>\n<li><strong>后置通知（After）</strong>：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>\n<li><strong>返回通知（After-returning ）</strong>：在目标方法成功执行之后调用通知；</li>\n<li><strong>异常通知（After-throwing）</strong>：在目标方法抛出异常后调用通知；</li>\n<li><strong>环绕通知（Around）</strong>：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的逻辑。</li>\n</ul>\n<h2 id=\"ioc\"><a class=\"anchor\" href=\"#ioc\">#</a> IOC</h2>\n<p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC 则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>\n<p>说到 IoC 就不得不说 DI（Dependency Injection），DI 是依赖注入的意思，它是 IoC 实现的实现方式，就是说 IoC 是通过 DI 来实现的。由于 IoC 这个词汇比较抽象而 DI 却更直观，所以很多时候我们就用 DI 来代替它，在很多时候我们简单地将 IoC 和 DI 划等号，这是一种习惯。而实现依赖注入的关键是 IoC 容器，它的本质就是一个工厂。</p>\n<p>在具体的实现中，主要由三种注入方式：</p>\n<p><strong>构造方法注入</strong></p>\n<p>就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider 会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</p>\n<p><strong>setter 方法注入</strong></p>\n<p>通过 setter 方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加 setter 方法，就可以通过 setter 方法将相应的依赖对象设置到被注入对象中。setter 方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。</p>\n<p><strong>接口注入</strong></p>\n<p>相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要 IoC Service Provider 为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider 最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和烦琐。</p>\n<h3 id=\"ioc-容器初始化过程\"><a class=\"anchor\" href=\"#ioc-容器初始化过程\">#</a> IOC 容器初始化过程</h3>\n<p>ioc 容器初始化过程：BeanDefinition 的资源定位、解析和注册。</p>\n<ul>\n<li>从 XML 中读取配置文件。</li>\n<li>将 bean 标签解析成 BeanDefinition，如解析 property 元素， 并注入到 BeanDefinition 实例中。</li>\n<li>将 BeanDefinition 注册到容器 BeanDefinitionMap 中。</li>\n<li>BeanFactory 根据 BeanDefinition 的定义信息创建实例化和初始化 bean。</li>\n</ul>\n<h3 id=\"beanfactory-applicationcontext\"><a class=\"anchor\" href=\"#beanfactory-applicationcontext\">#</a> BeanFactory &amp; ApplicationContext</h3>\n<p>它们都是 Spring 中的两个接口，用来获取 Spring 容器中的 bean。</p>\n<p><strong>BeanFactory</strong><br />\nspring 容器中具有代表性的容器就是 BeanFactory 接口，这个是 spring 容器的顶层接口，提供了容器最基本的功能。</p>\n<p><strong>ApplicationContext</strong><br />\n 应用上下文，继承 BeanFactory 接口，它是 Spring 的一各更高级的容器，提供了更多的有用的功能；</p>\n<ul>\n<li>国际化（MessageSource）</li>\n<li>访问资源，如 URL 和文件（ResourceLoader）</li>\n<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层</li>\n<li>消息发送、响应机制（ApplicationEventPublisher）</li>\n<li>AOP（拦截器）</li>\n</ul>\n<h4 id=\"装载-bean-的区别\"><a class=\"anchor\" href=\"#装载-bean-的区别\">#</a> 装载 bean 的区别</h4>\n<p><strong>BeanFactory</strong><br />\nBeanFactory 在启动的时候不会去实例化 Bean，中有从容器中拿 Bean 的时候才会去实例化；</p>\n<p><strong>ApplicationContext</strong><br />\nApplicationContext 在启动的时候就把所有的 Bean 全部实例化了。它还提供了更多的功能，如国际化、事件传播、资源加载等。它还可以为 Bean 配置  <code>lazy-init=true</code>  来让 Bean 延迟实例化；</p>\n<h3 id=\"循环依赖问题\"><a class=\"anchor\" href=\"#循环依赖问题\">#</a> 循环依赖问题</h3>\n<p>spring 对循环依赖的处理有三种情况：</p>\n<ul>\n<li>构造器的循环依赖：这种依赖 spring 是处理不了的，直接抛出 BeanCurrentlylnCreationException 异常。</li>\n<li>单例模式下的 setter 循环依赖：通过「三级缓存」处理循环依赖。</li>\n<li>非单例循环依赖：无法处理。</li>\n</ul>\n<p>Spring 在创建 Bean 的过程中分为三步：</p>\n<ol>\n<li>实例化，对应方法：AbstractAutowireCapableBeanFactory 中的 createBeanInstance 方法。</li>\n<li>属性注入，对应方法：AbstractAutowireCapableBeanFactory 的 populateBean 方法。</li>\n<li>初始化，对应方法：AbstractAutowireCapableBeanFactory 的 initializeBean 方法。</li>\n</ol>\n<p>Spring 为了解决单例的循环依赖问题，使用了三级缓存。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/** Cache of singleton objects: bean name –> bean instance */</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span> singletonObjects <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">/** Cache of singleton factories: bean name –> ObjectFactory */</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span><span class=\"token operator\">></span> singletonFactories <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">/** Cache of early singleton objects: bean name –> bean instance */</span> </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Map</span> earlySingletonObjects <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>三级缓存的作用</strong><br />\n <code>singletonFactories</code>  ： 进入实例化阶段的单例对象工厂的 cache （三级缓存）。<br />\n <code>earlySingletonObjects</code>  ：完成实例化但是尚未初始化的，提前暴光的单例对象的 Cache （二级缓存）。<br />\n <code>singletonObjects</code> ：完成初始化的单例对象的 cache（一级缓存）。</p>\n<p>步骤：</p>\n<ol>\n<li>Spring 首先从一级缓存 singletonObjects 中获取。</li>\n<li>如果获取不到，并且对象正在创建中，就再从二级缓存 earlySingletonObjects 中获取。</li>\n<li>如果还是获取不到且允许 singletonFactories 通过 getObject () 获取，就从三级缓存 singletonFactory.getObject ()（三级缓存）获取。</li>\n<li>如果从三级缓存中获取到就从 singletonFactories 中移除，并放入 earlySingletonObjects 中。其实也就是从三级缓存移动到了二级缓存。</li>\n</ol>\n<p>我们在创建 bean 的时候，会首先从 cache 中获取这个 bean，这个缓存就是 sigletonObjects。主要的调用方法是：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> allowEarlyReference<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 1. 先从一级缓存中获取，获取到直接返回</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">Object</span> singletonObject <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 2. 如果获取不到并且对象正在创建，就到二级缓存中去获取，获取到直接返回</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singletonObject <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isSingletonCurrentlyInCreation</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            singletonObject <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>earlySingletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token comment\">// 3. 如果仍获取不到，且允许 singletonFactories (allowEarlyCurrentlyInCreation ()）通过 getObject () 获取。</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token comment\">// 就到三级缓存中用 getObject () 获取。</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token comment\">// 获取到就从 singletonFactories 中移出，且放进 earlySingletonObjects。</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token comment\">//（即从三级缓存移动到二级缓存）</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singletonObject <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> allowEarlyReference<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                <span class=\"token class-name\">ObjectFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> singletonFactory <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonFactories<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singletonFactory <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                    singletonObject <span class=\"token operator\">=</span> singletonFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>earlySingletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> singletonObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonFactories<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">return</span> singletonObject<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>从三级缓存的分析来看，Spring 解决循环依赖的诀窍就在于 singletonFactories 这个滴三级 cache。这个 cache 的类型是 ObjectFactory，定义如下：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ObjectFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">T</span> <span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>该类型在 <code>addSingletonFactory</code>  方法中引用。方法又被 <code>doCreateBean</code>  调用。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addSingletonFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ObjectFactory</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> singletonFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>     </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notNull</span><span class=\"token punctuation\">(</span>singletonFactory<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Singleton factory must not be null\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>         </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonFactories<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> singletonFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>             </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>earlySingletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>registeredSingletons<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span>     </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><strong>doCreateBean</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 保存的是 FactoryBean 的 beanName -> FactoryBean 的 BeanWrapper</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ConcurrentMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BeanWrapper</span><span class=\"token punctuation\">></span></span> factoryBeanInstanceCache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">doCreateBean</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">RootBeanDefinition</span> mbd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token annotation punctuation\">@Nullable</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeanCreationException</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// Instantiate the bean.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token class-name\">BeanWrapper</span> instanceWrapper <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">isSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">// 单例情况下清除缓存。这里保存的是 FactoryBean 和 BeanWrapper 的映射关系。 </span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">//factoryBeanInstanceCache 是在创建其他 bean 的时候缓存了一下 FactoryBean 。至于单例模式下移除而不是获取，因为单例只需要创建一次 ？ 尚未理解。</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        instanceWrapper <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>factoryBeanInstanceCache<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 如果没有缓存，则重新创建</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instanceWrapper <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token comment\">// 1. 根据指定的 bean 使用对应的策略创建新的实例。如：工厂方法、构造函数自动注入，简单初始化</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        instanceWrapper <span class=\"token operator\">=</span> <span class=\"token function\">createBeanInstance</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// 获取 bean 实例</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> bean <span class=\"token operator\">=</span> instanceWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">getWrappedInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// 获取 bean 类型</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> beanType <span class=\"token operator\">=</span> instanceWrapper<span class=\"token punctuation\">.</span><span class=\"token function\">getWrappedClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// 将目标类型替换成实际生成的类型。纠正了上面说到类型错误（如果存在）</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>beanType <span class=\"token operator\">!=</span> <span class=\"token class-name\">NullBean</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        mbd<span class=\"token punctuation\">.</span>resolvedTargetType <span class=\"token operator\">=</span> beanType<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">// Allow post-processors to modify the merged bean definition.</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token comment\">// 2. 调用  MergedBeanDefinitionPostProcessor 后处理器</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>mbd<span class=\"token punctuation\">.</span>postProcessingLock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mbd<span class=\"token punctuation\">.</span>postProcessed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                <span class=\"token comment\">// 调用  MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition 后处理器的方法。</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                <span class=\"token function\">applyMergedBeanDefinitionPostProcessors</span><span class=\"token punctuation\">(</span>mbd<span class=\"token punctuation\">,</span> beanType<span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BeanCreationException</span><span class=\"token punctuation\">(</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">getResourceDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                        <span class=\"token string\">\"Post-processing of merged bean definition failed\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            mbd<span class=\"token punctuation\">.</span>postProcessed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token comment\">// Eagerly cache singletons to be able to resolve circular references</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token comment\">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token comment\">// 3. 判断是否需要提早曝光 ： 单例 &amp; 允许循环依赖 &amp; 当前 bean 已经正在创建中</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token comment\">// 由于当前 bean 已经在创建中，本次创建必然是循环引用造成的，所以这里判断是否可以需要提前曝光</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token keyword\">boolean</span> earlySingletonExposure <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">isSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>allowCircularReferences <span class=\"token operator\">&amp;&amp;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>            <span class=\"token function\">isSingletonCurrentlyInCreation</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>earlySingletonExposure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">isTraceEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>            logger<span class=\"token punctuation\">.</span><span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Eagerly caching bean '\"</span> <span class=\"token operator\">+</span> beanName <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>                    <span class=\"token string\">\"' to allow for resolving potential circular references\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token comment\">// 4. 为避免后期循环依赖，在 bean 初始化完成前将创建实例的 ObjectFactory 加入工程  -- 解决循环依赖</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token function\">addSingletonFactory</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token comment\">// Initialize the bean instance.</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token class-name\">Object</span> exposedObject <span class=\"token operator\">=</span> bean<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>        <span class=\"token comment\">//  5. 对 bean 进行属性填充，将各个属性值注入，其中如果存在依赖于其他 bean 的属性，则会递归初始依赖 bean</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        <span class=\"token function\">populateBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> instanceWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token comment\">// 调用初始化方法，比如 init-method</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>        exposedObject <span class=\"token operator\">=</span> <span class=\"token function\">initializeBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> exposedObject<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ex <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">BeanCreationException</span> <span class=\"token operator\">&amp;&amp;</span> beanName<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BeanCreationException</span><span class=\"token punctuation\">)</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBeanName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>            <span class=\"token keyword\">throw</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BeanCreationException</span><span class=\"token punctuation\">)</span> ex<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BeanCreationException</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>                    mbd<span class=\"token punctuation\">.</span><span class=\"token function\">getResourceDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Initialization of bean failed\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    <span class=\"token comment\">// 6. 进行循环依赖检查</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>earlySingletonExposure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>        <span class=\"token class-name\">Object</span> earlySingletonReference <span class=\"token operator\">=</span> <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>        <span class=\"token comment\">//earlySingletonReference  只有在检测到有循环依赖的情况下才会不为空</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>earlySingletonReference <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>        <span class=\"token comment\">// 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>exposedObject <span class=\"token operator\">==</span> bean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>                exposedObject <span class=\"token operator\">=</span> earlySingletonReference<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>allowRawInjectionDespiteWrapping <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">hasDependentBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>                <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dependentBeans <span class=\"token operator\">=</span> <span class=\"token function\">getDependentBeans</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>                <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> actualDependentBeans <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedHashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>dependentBeans<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> dependentBean <span class=\"token operator\">:</span> dependentBeans<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>                    <span class=\"token comment\">// 检测依赖</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">removeSingletonIfCreatedForTypeCheckOnly</span><span class=\"token punctuation\">(</span>dependentBean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>                        actualDependentBeans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>dependentBean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>                    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>                <span class=\"token comment\">// 因为 bean 创建后其所依赖的 bean 一定是已经创建了的。actualDependentBeans 不为空说明当前 bean 创建后其依赖的 bena 却没有全部创建完，也就说说存在循环依赖。</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>actualDependentBeans<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BeanCurrentlyInCreationException</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>                            <span class=\"token string\">\"Bean with name '\"</span> <span class=\"token operator\">+</span> beanName <span class=\"token operator\">+</span> <span class=\"token string\">\"' has been injected into other beans [\"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>                            <span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">collectionToCommaDelimitedString</span><span class=\"token punctuation\">(</span>actualDependentBeans<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>                            <span class=\"token string\">\"] in its raw version as part of a circular reference, but has eventually been \"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>                            <span class=\"token string\">\"wrapped. This means that said other beans do not use the final version of the \"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>                            <span class=\"token string\">\"bean. This is often the result of over-eager type matching - consider using \"</span> <span class=\"token operator\">+</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>                            <span class=\"token string\">\"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>    <span class=\"token comment\">// Register bean as disposable.</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre>        <span class=\"token comment\">// 7. 根据 Scopse 注册 bean</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre>        <span class=\"token function\">registerDisposableBeanIfNecessary</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> bean<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre>    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BeanDefinitionValidationException</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BeanCreationException</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>                mbd<span class=\"token punctuation\">.</span><span class=\"token function\">getResourceDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Invalid destruction signature\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre></pre></td></tr><tr><td data-num=\"118\"></td><td><pre>    <span class=\"token keyword\">return</span> exposedObject<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"119\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>doCreateBean</code>  大致逻辑如下：</p>\n<ol>\n<li><code>createBeanInstance(beanName, mbd, args);</code>  ：实例化 bean，将 BeanDefinition 转换为 BeanWrapper</li>\n<li><code>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</code>  ： MergedBeanDefinitionPostProcessor 后处理器的应用。bean 合并后的处理，比如 @Autowired、@Value 注解正是通过 AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition 此方法实现的预解析。</li>\n<li><code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</code>  ： 关于循环依赖的处理，添加 ObjectFactory 到 singletonFactories 缓存中，同时这里给了用户一个机会通过调用 SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference 方法来由用户生成暴露的实例</li>\n<li><code>populateBean(beanName, mbd, instanceWrapper);</code>  ：对创建的 bean 内部的一些属性进行填充注入</li>\n<li><code>initializeBean(beanName, exposedObject, mbd);</code>  ： 初始化 bean 的一些属性，如 Aware 接口的实现， init-method 属性等</li>\n<li>循环依赖检查。和第四步不同的是，这里了是判断是否无法解决循环依赖，否则抛出异常。</li>\n<li><code>registerDisposableBeanIfNecessary(beanName, bean, mbd);</code>  ： 注册 DisposableBean</li>\n<li>完成创建并返回。</li>\n</ol>\n<p><strong>addSingletonFactory</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">addSingletonFactory</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这一部分的逻辑就是为了解决循环依赖的问题，将未创建完成的当前 bean，通过 ObjectFactory 进行一个包装，提前暴露给其他 bean。</p>\n<p><strong>getEarlyBeanReference</strong></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">,</span> <span class=\"token class-name\">RootBeanDefinition</span> mbd<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> bean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token class-name\">Object</span> exposedObject <span class=\"token operator\">=</span> bean<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">isSynthetic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">hasInstantiationAwareBeanPostProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BeanPostProcessor</span> bp <span class=\"token operator\">:</span> <span class=\"token function\">getBeanPostProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bp <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartInstantiationAwareBeanPostProcessor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                <span class=\"token class-name\">SmartInstantiationAwareBeanPostProcessor</span> ibp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SmartInstantiationAwareBeanPostProcessor</span><span class=\"token punctuation\">)</span> bp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                exposedObject <span class=\"token operator\">=</span> ibp<span class=\"token punctuation\">.</span><span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>exposedObject<span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> exposedObject<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所有的</p>\n<h2 id=\"bean\"><a class=\"anchor\" href=\"#bean\">#</a> Bean</h2>\n<h3 id=\"spring-如何管理-bean\"><a class=\"anchor\" href=\"#spring-如何管理-bean\">#</a> Spring 如何管理 Bean</h3>\n<p>Spring 通过 IoC 容器来管理 Bean，我们可以通过 XML 配置或者注解配置，来指导 IoC 容器对 Bean 的管理。因为注解配置比 XML 配置方便很多，所以现在大多时候会使用注解配置的方式。</p>\n<p>以下是管理 Bean 时常用的一些注解：</p>\n<p><code>@ComponentScan</code>  用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。</p>\n<p><code>@Component</code> 、 <code>@Repository</code> 、 <code>@Service</code> 、 <code>@Controller</code>  用于声明 Bean，它们的作用一样，但是语义不同。@Component 用于声明通用的 Bean， <code>@Repository</code>  用于声明 DAO 层的 Bean，@Service 用于声明业务层的 Bean， <code>@Controller</code>  用于声明视图层的控制器 Bean，被这些注解声明的类就可以被容器扫描并创建。</p>\n<p><code>@Autowired</code> 、 <code>@Qualifier</code>  用于注入 Bean，即告诉容器应该为当前属性注入哪个 Bean。其中，@Autowired 是按照 Bean 的类型进行匹配的，如果这个属性的类型具有多个 Bean，就可以通过 @Qualifier 指定 Bean 的名称，以消除歧义。</p>\n<p><code>@Scope</code>  用于声明 Bean 的作用域，默认情况下 Bean 是单例的，即在整个容器中这个类型只有一个实例。可以通过 <code>@Scope</code>  注解指定 prototype 值将其声明为多例的，也可以将 Bean 声明为 session 级作用域、request 级作用域等等，但最常用的还是默认的单例模式。</p>\n<p><code>@PostConstruct</code> 、 <code>@PreDestroy</code>  用于声明 Bean 的生命周期。其中，被 <code>@PostConstruct</code>  修饰的方法将在 Bean 实例化后被调用， <code>@PreDestroy</code>  修饰的方法将在容器销毁前被调用。</p>\n<h3 id=\"bean-的作用域\"><a class=\"anchor\" href=\"#bean-的作用域\">#</a> Bean 的作用域</h3>\n<p>默认情况下，Bean 在 Spring 容器中是单例的，我们可以通过 @Scope 注解修改 Bean 的作用域。该注解有如下 5 个取值，它们代表了 Bean 的 5 种不同类型的作用域：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>singleton</td>\n<td>在 Spring 容器中仅存在一个实例，即 Bean 以单例的形式存在。</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>每次调用 getBean () 时，都会执行 new 操作，返回一个新的实例。</td>\n</tr>\n<tr>\n<td>request</td>\n<td>每次 HTTP 请求都会创建一个新的 Bean。</td>\n</tr>\n<tr>\n<td>session</td>\n<td>同一个 HTTP</td>\n<td>Session 共享一个 Bean，不同的 HTTP Session 使用不同的 Bean。</td>\n</tr>\n<tr>\n<td>globalSession</td>\n<td>同一个全局的 Session 共享一个 Bean，一般用于 Portlet 环境。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"bean-的生命周期\"><a class=\"anchor\" href=\"#bean-的生命周期\">#</a> Bean 的生命周期</h3>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311011911438.png\" alt=\"\" /></p>\n<p>Spring bean 的生命周期只有四个主要阶段，其他都是在这四个主要阶段前后的扩展点，这四个阶段是：</p>\n<ol>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ol>\n<h3 id=\"beanfactory-factorybean\"><a class=\"anchor\" href=\"#beanfactory-factorybean\">#</a> BeanFactory &amp; FactoryBean</h3>\n<p><code>BeanFactory</code> ：管理 Bean 的容器，Spring 中生成的 Bean 都是由这个接口的实现来管理的。</p>\n<p><code>FactoryBean</code> ：通常是用来创建比较复杂的 bean，一般的 bean 直接用 xml 配置即可，但如果一个 bean 的创建过程中涉及到很多其他的 bean 和复杂的逻辑，直接用 xml 配置比较麻烦，这时可以考虑用 FactoryBean，可以隐藏实例化复杂 Bean 的细节。<br />\n当配置文件中 bean 标签的 class 属性配置的实现类是 FactoryBean 时，通过 getBean () 方法返回的不是 FactoryBean 本身，而是调用 FactoryBean#getObject () 方法所返回的对象，相当于 FactoryBean#getObject () 代理了 getBean () 方法。如果想得到 FactoryBean 必须使用 '&amp;' + beanName 的方式获取。</p>\n<h3 id=\"bean-注入容器的方式\"><a class=\"anchor\" href=\"#bean-注入容器的方式\">#</a> Bean 注入容器的方式</h3>\n<p>将普通类交给 Spring 容器管理，通常有以下方法：</p>\n<p>1、使用 <code>@Configuration</code>  与 <code>@Bean</code>  注解<br />\n 2、使用 <code>@Controller</code> 、 <code>@Service</code> 、 <code>@Repository</code> 、 <code>@Component</code>  注解标注该类，然后启用 <code>@ComponentScan</code>  自动扫描<br />\n 3、使用 <code>@Import</code>  注解把 bean 导入到当前容器中。</p>\n<h2 id=\"其它问题\"><a class=\"anchor\" href=\"#其它问题\">#</a> 其它问题</h2>\n<h3 id=\"autowired-resource\"><a class=\"anchor\" href=\"#autowired-resource\">#</a> @Autowired &amp; @Resource</h3>\n<ul>\n<li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li>\n<li>@Autowired 是只能按类型注入，@Resource 默认按名称注入，也支持按类型注入。</li>\n<li>@Autowired 按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它 required 属性为 false，如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。@Resource 有两个中重要的属性：name 和 type。name 属性指定 byName，如果没有指定 name 属性，当注解标注在字段上，即默认取字段的名称作为 bean 名称寻找依赖对象，当注解标注在属性的 setter 方法上，即默认取属性名作为 bean 名称寻找依赖对象。需要注意的是，@Resource 如果没有指定 name 属性，并且按照默认的名称仍然找不到依赖对象时， @Resource 注解会回退到按类型装配。但一旦指定了 name 属性，就只能按名称装配了。</li>\n</ul>\n<h3 id=\"spring-中默认提供的单例是线程安全的吗\"><a class=\"anchor\" href=\"#spring-中默认提供的单例是线程安全的吗\">#</a> Spring 中默认提供的单例是线程安全的吗</h3>\n<p><strong>不是线程安全的</strong>，Spring 容器本身并没有提供 Bean 的线程安全策略。如果单例的 Bean 是一个无状态的 Bean，即线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例的 Bean 是线程安全的。比如，Controller、Service、DAO 这样的组件，通常都是单例且线程安全的。如果单例的 Bean 是一个有状态的 Bean，则可以采用 ThreadLocal 对状态数据做线程隔离，来保证线程安全。</p>\n<h3 id=\"spring-如何管理事务\"><a class=\"anchor\" href=\"#spring-如何管理事务\">#</a> Spring 如何管理事务？</h3>\n<p>参考答案</p>\n<p>Spring 为事务管理提供了一致的编程模板，在高层次上建立了统一的事务抽象。也就是说，不管是选择 MyBatis、Hibernate、JPA 还是 Spring JDBC，Spring 都可以让用户以统一的编程模型进行事务管理。</p>\n<h3 id=\"spring-支持两种事务编程模型\"><a class=\"anchor\" href=\"#spring-支持两种事务编程模型\">#</a> Spring 支持两种事务编程模型：</h3>\n<p><strong>编程式事务</strong><br />\n Spring 提供了 TransactionTemplate 模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确。</p>\n<p><strong>声明式事务</strong><br />\n Spring 事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在 IoC 配置中指定事务的边界和事务属性，Spring 会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加 @Transactional 注解，以声明事务特征即可。</p>\n<h3 id=\"spring-自动装配的方式有哪些\"><a class=\"anchor\" href=\"#spring-自动装配的方式有哪些\">#</a> Spring 自动装配的方式有哪些</h3>\n<p>Spring 的自动装配有三种模式：byType（根据类型），byName（根据名称）、constructor（根据构造函数）。</p>\n<h2 id=\"spring-boot\"><a class=\"anchor\" href=\"#spring-boot\">#</a> Spring Boot</h2>\n<p>从本质上来说，Spring Boot 就是 Spring，它做了那些没有它你自己也会去做的 Spring Bean 配置。Spring Boot 使用 “习惯优于配置” 的理念让你的项目快速地运行起来，使用 Spring Boot 很容易创建一个能独立运行、准生产级别、基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需要很少的 Spring 配置。</p>\n<p>简而言之，Spring Boot 本身并不提供 Spring 的核心功能，而是作为 Spring 的脚手架框架，以达到快速构建项目、预置三方配置、开箱即用的目的。Spring Boot 有如下的优点：</p>\n<ul>\n<li>可以快速构建项目；</li>\n<li>可以对主流开发框架的无配置集成；</li>\n<li>项目可独立运行，无需外部依赖 Servlet 容器；</li>\n<li>提供运行时的应用监控；</li>\n<li>可以极大地提高开发、部署效率；</li>\n<li>可以与云计算天然集成。</li>\n</ul>\n<h3 id=\"核心注解\"><a class=\"anchor\" href=\"#核心注解\">#</a> 核心注解</h3>\n<p>核心注解是 @SpringBootApplication，它主要由 @SpringBootConfiguration，@EnableAutoConfiguration 和 @ComponentScan 这三个构成</p>\n<ul>\n<li>\n<p><code>@SpringBootConfiguration</code>  里面就只有一个 @Configuration 主要注解，也就是把该类变成一个配置类所以 @SpringBootConfiguration 就相当于 @Configuration。</p>\n</li>\n<li>\n<p><code>@EnableAutoConfiguration</code>  是由 @AutoConfigurationPackage 和 @Import (EnableAutoConfigurationImportSelector.class) 这两个组成的</p>\n<ul>\n<li>@AutoConfigurationPackage 是自动配置包，包括了一个 @Import 注解，给容器导入了自动配置包的注册器，AutoConfigurationPackages.Registrar.class：将主启动类的所在包及包下面所有子包里面的所有组件扫描到 Spring 容器</li>\n<li>@Import (AutoConfigurationImportSelector.class)：导入自动配置导入选择器组件，AutoConfigurationImportSelector.class：自动配置导入选择器，主要是从类路径下的 META-INF/spring.factories 中获取资源</li>\n</ul>\n</li>\n<li>\n<p><code> @ComponentScan</code> ：扫描包，该注解默认会扫描该类所在的包下所有的配置类</p>\n</li>\n</ul>\n<h3 id=\"启动流程\"><a class=\"anchor\" href=\"#启动流程\">#</a> 启动流程</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">ConfigurableApplicationContext</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 创建 StopWatch，用于统计 Springboot 启动的耗时</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token class-name\">StopWatch</span> stopWatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StopWatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 开始计时</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    stopWatch<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token class-name\">DefaultBootstrapContext</span> bootstrapContext <span class=\"token operator\">=</span> <span class=\"token function\">createBootstrapContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token class-name\">ConfigurableApplicationContext</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">configureHeadlessProperty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 获取运行时监听器</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token class-name\">SpringApplicationRunListeners</span> listeners <span class=\"token operator\">=</span> <span class=\"token function\">getRunListeners</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 调用运行时监听器的 starting () 方法</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 该方法需要在 Springboot 一启动时就调用，用于特别早期的初始化</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    listeners<span class=\"token punctuation\">.</span><span class=\"token function\">starting</span><span class=\"token punctuation\">(</span>bootstrapContext<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mainApplicationClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token comment\">// 获取 args 参数对象</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token class-name\">ApplicationArguments</span> applicationArguments <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultApplicationArguments</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">// 读取 Springboot 配置文件并创建 Environment 对象</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// 这里创建的 Environment 对象实际为 ConfigurableEnvironment</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token class-name\">ConfigurableEnvironment</span> environment <span class=\"token operator\">=</span> <span class=\"token function\">prepareEnvironment</span><span class=\"token punctuation\">(</span>listeners<span class=\"token punctuation\">,</span> bootstrapContext<span class=\"token punctuation\">,</span> applicationArguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token function\">configureIgnoreBeanInfo</span><span class=\"token punctuation\">(</span>environment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token comment\">// 打印 Banner 图标</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token class-name\">Banner</span> printedBanner <span class=\"token operator\">=</span> <span class=\"token function\">printBanner</span><span class=\"token punctuation\">(</span>environment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token comment\">// 创建 ApplicationContext 应用行下文，即创建容器</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        context <span class=\"token operator\">=</span> <span class=\"token function\">createApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        context<span class=\"token punctuation\">.</span><span class=\"token function\">setApplicationStartup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>applicationStartup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">// 准备容器</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token function\">prepareContext</span><span class=\"token punctuation\">(</span>bootstrapContext<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> environment<span class=\"token punctuation\">,</span> listeners<span class=\"token punctuation\">,</span> applicationArguments<span class=\"token punctuation\">,</span> printedBanner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token comment\">// 初始化容器</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token function\">refreshContext</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token function\">afterRefresh</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> applicationArguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token comment\">// 停止计时</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        stopWatch<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logStartupInfo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token comment\">// 打印启动耗时等信息</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>            <span class=\"token keyword\">new</span> <span class=\"token class-name\">StartupInfoLogger</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mainApplicationClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">logStarted</span><span class=\"token punctuation\">(</span><span class=\"token function\">getApplicationLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> stopWatch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token comment\">// 调用运行时监听器的 started () 方法</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token comment\">// 该方法需要在应用程序启动后，CommandLineRunners 和 ApplicationRunners 被调用前执行</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        listeners<span class=\"token punctuation\">.</span><span class=\"token function\">started</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token function\">callRunners</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> applicationArguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token function\">handleRunFailure</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">,</span> listeners<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token comment\">// 调用运行时监听器的 running () 方法</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token comment\">// 该方法需要在 SpringApplication 的 run () 方法执行完之前被调用</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>        listeners<span class=\"token punctuation\">.</span><span class=\"token function\">running</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token function\">handleRunFailure</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token keyword\">return</span> context<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311021821659.jpg\" alt=\"\" /></p>\n<p>SpringApplication 在 run 方法中重点做了以下操作：</p>\n<ul>\n<li>获取监听器和参数配置；</li>\n<li>打印 Banner 信息；</li>\n<li>创建并初始化容器；</li>\n<li>监听器发送通知。</li>\n</ul>\n<h2 id=\"spring-cloud\"><a class=\"anchor\" href=\"#spring-cloud\">#</a> Spring Cloud</h2>\n<p>Spring Cloud 是一整套基于 Spring Boot 的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：配置管理、注册中心、服务发现、限流、网关、链路追踪等。</p>\n<h3 id=\"核心组件\"><a class=\"anchor\" href=\"#核心组件\">#</a> 核心组件</h3>\n<ol>\n<li>注册中心组件（服务治理）：Netflix Eureka；</li>\n<li>负载均衡组件：Netflix Ribbon，各个微服务进行分摊，提高性能；</li>\n<li>熔断器组件（断路器）：Netflix Hystrix，Resilience4j ；保护系统，控制故障范围；</li>\n<li>网关服务组件：Zuul，Spring Cloud Gateway；api 网关，路由，负载均衡等多种作用；</li>\n<li>配置中心：Spring Cloud Config，将配置文件组合起来，放在远程仓库，便于管理；</li>\n</ol>\n",
            "tags": [
                "面试指北",
                "Web",
                "八股文",
                "Spring",
                "Web"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/10/28/2023-10-interview-db-redis/",
            "url": "https://haust-kevin.github.io/2023/10/28/2023-10-interview-db-redis/",
            "title": "面试指北：Redis 数据库",
            "date_published": "2023-10-28T07:01:27.000Z",
            "content_html": "<h2 id=\"redis\"><a class=\"anchor\" href=\"#redis\">#</a> Redis</h2>\n<p>Redis，英文全称是 Remote Dictionary Server（远程字典服务），是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</p>\n<p>与 MySQL 数据库不同的是， Redis 的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过 10 万次读写操作。因此 redis 被广泛应用于缓存，另外， Redis 也经常用来做分布式锁。除此之外， Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p>\n<h3 id=\"redis-为何这么快\"><a class=\"anchor\" href=\"#redis-为何这么快\">#</a> Redis 为何这么快</h3>\n<ul>\n<li>Redis 是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在 IO 上，所以读取速度快。</li>\n<li>Redis 使用的是非阻塞 IO 、 IO 多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</li>\n</ul>\n<h3 id=\"为何使用单线程\"><a class=\"anchor\" href=\"#为何使用单线程\">#</a> 为何使用单线程</h3>\n<p>因为 Redis 是基于内存的操作，CPU 不会成为 Redis 的瓶颈，而最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<h3 id=\"redis-在持久化时-fork-出一个子进程这时已经有两个进程了怎么能说是单线程呢\"><a class=\"anchor\" href=\"#redis-在持久化时-fork-出一个子进程这时已经有两个进程了怎么能说是单线程呢\">#</a> Redis 在持久化时 fork 出一个子进程，这时已经有两个进程了，怎么能说是单线程呢</h3>\n<p>Redis 是单线程的，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的。而 Redis 的其他功能，如<strong>持久化</strong>、<strong>异步删除</strong>、<strong>集群数据同步</strong>等，则是依赖其他线程来执行的。所以，说 Redis 是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。</p>\n<h3 id=\"如何保证-redis-的高并发\"><a class=\"anchor\" href=\"#如何保证-redis-的高并发\">#</a> 如何保证 Redis 的高并发</h3>\n<p>Redis 通过主从加集群架构，实现读写分离，主节点负责写，并将数据同步给其他从节点，从节点负责读，从而实现高并发。</p>\n<h2 id=\"持久化\"><a class=\"anchor\" href=\"#持久化\">#</a> 持久化</h2>\n<p>redis 提供了两种持久化的方式，分别是 RDB（Redis DataBase）和 AOF（Append Only File）。</p>\n<p>RDB ，简而言之，就是在不同的时间点，将 redis 存储的数据生成快照并存储到磁盘等介质上。</p>\n<p>AOF，则是换了一个角度来实现持久化，那就是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p>\n<p>其实 RDB 和 AOF 两种方式也可以同时使用，在这种情况下，如果 redis 重启的话，则会优先采用 AOF 方式来进行数据恢复，这是因为 AOF 方式的数据恢复完整度更高。</p>\n<h3 id=\"rdb-持久化\"><a class=\"anchor\" href=\"#rdb-持久化\">#</a> RDB 持久化</h3>\n<p>RDB 方式，是将 redis 某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p>\n<p>redis 在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p>\n<p>对于 RDB 方式，redis 会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何 IO 操作的，这样就确保了 redis 极高的性能。</p>\n<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。</p>\n<p>缺点： RDB 文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的。</p>\n<h3 id=\"aof-持久化\"><a class=\"anchor\" href=\"#aof-持久化\">#</a> AOF 持久化</h3>\n<p>AOF，英文是 Append Only File，即只允许追加不允许改写的文件。</p>\n<p>因为采用了追加方式，如果不做任何处理的话，AOF 文件会变得越来越大，为此，redis 提供了 AOF 文件重写（rewrite）机制，即当 AOF 文件的大小超过所设定的阈值时，redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。<br />\n与 RDB 持久化相对应， AOF 的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p>\n<h3 id=\"aof-重写\"><a class=\"anchor\" href=\"#aof-重写\">#</a> AOF 重写</h3>\n<p>在重写即将开始之际，redis 会创建（fork）一个 “重写子进程”，这个子进程会首先读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p>\n<p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</p>\n<p>当 “重写子进程” 完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中。</p>\n<p>当追加结束后，redis 就会用新 AOF 文件来代替旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中了。</p>\n<h3 id=\"过期键删除策略\"><a class=\"anchor\" href=\"#过期键删除策略\">#</a> 过期键删除策略</h3>\n<ul>\n<li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器 timer。让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>\n<li><strong>惰性删除</strong>：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键。如果没有过期，就返回该键。</li>\n<li><strong>定期删除</strong>：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>\n</ul>\n<p>在上述的三种策略中定时删除和定期删除属于不同时间粒度的主动删除，惰性删除属于被动删除。三种策略都有各自的优缺点：</p>\n<ul>\n<li>定时删除 对内存使用率有优势，但是对 CPU 不友好。</li>\n<li>惰性删除 对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费。</li>\n<li>定期删除 是定时删除和惰性删除的折中。</li>\n</ul>\n<h4 id=\"redis-实现\"><a class=\"anchor\" href=\"#redis-实现\">#</a> Redis 实现</h4>\n<p>Reids 采用的是<strong>惰性删除</strong>和<strong>定期删除</strong>的结合，一般来说可以借助<strong>最小堆</strong>来实现定时器，不过 Redis 的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，这样如果在此基础上实现定时删除，就意味着 O (N) 遍历获取最近需要删除的数据。</p>\n<h5 id=\"定期删除策略\"><a class=\"anchor\" href=\"#定期删除策略\">#</a> 定期删除策略</h5>\n<p>Redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，默认每 100ms 进行一次过期扫描：</p>\n<ul>\n<li>对于每个数据库：\n<ul>\n<li>随机抽取 20 次 key</li>\n<li>删除这 20（可能存在重复） 个 key 中过期的 key</li>\n</ul>\n</li>\n<li>删除期间达到时间限制，结束本次删除。</li>\n</ul>\n<p><strong>从库的过期策略</strong><br />\n从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>\n<h3 id=\"内存淘汰策略\"><a class=\"anchor\" href=\"#内存淘汰策略\">#</a> 内存淘汰策略</h3>\n<ul>\n<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。这个一般很少用。</li>\n<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key ，这个是最常用的。</li>\n<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key 。</li>\n<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key 。</li>\n<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key 。</li>\n<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li>\n</ul>\n<p><strong>LRU 算法</strong><br />\n推荐一篇文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83Mjg5NjYyNDc2NzM5ODA1MjQx\">为什么 LRU 算法原理和代码实现不一样？</span></p>\n<h2 id=\"数据存储\"><a class=\"anchor\" href=\"#数据存储\">#</a> 数据存储</h2>\n<p>Redis 数据结构</p>\n<ul>\n<li>字符串 String</li>\n<li>字典 Hash</li>\n<li>列表 List</li>\n<li>集合 Set</li>\n<li>有序集合 Zset</li>\n</ul>\n<h3 id=\"redis-对象\"><a class=\"anchor\" href=\"#redis-对象\">#</a> Redis 对象</h3>\n<p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">redisObject</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 类型</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> type<span class=\"token operator\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 编码</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> encoding<span class=\"token operator\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 指向底层实现数据结构的指针</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 引用计数</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> refcount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span> robj<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"内存回收\"><a class=\"anchor\" href=\"#内存回收\">#</a> 内存回收</h4>\n<p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>\n<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>\n<ul>\n<li>在创建一个新对象时， 引用计数的值会被初始化为 1 。</li>\n<li>当对象被一个新程序使用时， 它的引用计数值会被增一。</li>\n<li>当对象不再被一个程序使用时， 它的引用计数值会被减一。</li>\n<li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li>\n</ul>\n<h3 id=\"字典的实现\"><a class=\"anchor\" href=\"#字典的实现\">#</a> 字典的实现</h3>\n<p>Redis 中的字典由 dict.h/dict 结构表示：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">dict</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 类型特定函数</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    dictType <span class=\"token operator\">*</span>type<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 私有数据</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 哈希表</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    dictht ht<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">//rehash 索引</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 当 rehash 不在进行时，值为 -1</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">int</span> rehashidx<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* rehashing not in progress if rehashidx == -1 */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span> dict<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>\n<ul>\n<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>\n<li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>\n</ul>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">dictType</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 计算哈希值的函数</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>hashFunction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 复制键的函数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>keyDup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 复制值的函数</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>valDup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 对比键的函数</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>keyCompare<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 销毁键的函数</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>keyDestructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 销毁值的函数</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>valDestructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span> dictType<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht [0] 哈希表， ht [1] 哈希表只会在对 ht [0] 哈希表进行 rehash 时使用。</p>\n<p>除了 ht [1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。<br />\n<img data-src=\"http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png\" alt=\"\" /></p>\n<h3 id=\"哈希冲突\"><a class=\"anchor\" href=\"#哈希冲突\">#</a> 哈希冲突</h3>\n<p>Redis 通过<strong>链式哈希</strong>解决冲突，也就是同一个桶里面的元素使用<strong>单向链表</strong>保存。但是当链表过长就会导致查找性能变差可能。所以 Redis 为了追求块，使用了两个全局哈希表。用于 rehash 操作，增加现有的哈希桶数量，减少哈希冲突。<br />\n因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O (1)）， 排在其他已有节点的前面。</p>\n<h3 id=\"扩容\"><a class=\"anchor\" href=\"#扩容\">#</a> 扩容</h3>\n<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>\n<p>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 。<br />\n服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 。<br />\n其中哈希表的负载因子可以通过公式：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>load_factor <span class=\"token operator\">=</span> ht<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>used <span class=\"token operator\">/</span> ht<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>size</pre></td></tr></table></figure><h4 id=\"rehash\"><a class=\"anchor\" href=\"#rehash\">#</a> rehash</h4>\n<ul>\n<li>定时任务：Redis 定时任务 serverCron 会在每个周期内执行 1ms 渐进式 Rehash 操作。</li>\n<li>附着于其他操作：在 Redis 执行 dictAddRaw, dictGenericDelete, dictFind, dictGetSomeKeys 和 dictGetRandomKey 等操作前会执行 Rehash 操作。</li>\n</ul>\n<h4 id=\"渐进式-rehash\"><a class=\"anchor\" href=\"#渐进式-rehash\">#</a> 渐进式 rehash</h4>\n<p>扩展或收缩哈希表需要将 ht [0] 里面的所有键值对 rehash 到 ht [1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>\n<p><strong>哈希表渐进式 rehash 的详细步骤：</strong></p>\n<ul>\n<li>为 ht [1] 分配空间， 让字典同时持有 ht [0] 和 ht [1] 两个哈希表。</li>\n<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht [0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht [1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， ht [0] 的所有键值对都会被 rehash 至 ht [1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>\n</ul>\n<p><strong>渐进式 rehash 执行期间的哈希表操作</strong><br />\n因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht [0] 和 ht [1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht [0] 里面进行查找， 如果没找到的话， 就会继续到 ht [1] 里面进行查找， 诸如此类。</p>\n<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht [1] 里面， 而 ht [0] 则不再进行任何添加操作： 这一措施保证了 ht [0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>\n<h2 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h2>\n<p>Redis 事务没有回滚机制<br />\n Redis 通过 MULTI，EXEC，WATCH 等命令来实现事务功能。<br />\n事务首先以一个 MULTI 命令 开始，然后将多个命令放入事务中，最后由 EXEC 命令将这个事务提交给服务器执行。</p>\n<h3 id=\"事务的三个阶段\"><a class=\"anchor\" href=\"#事务的三个阶段\">#</a> 事务的三个阶段</h3>\n<ul>\n<li>事务开始</li>\n<li>命令入队</li>\n<li>事务执行</li>\n</ul>\n<p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p>\n<p>如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。<br />\n如果客户端发送的命令是 EXEC、DISCARD、WATCH、MULTI 四个命令 以外的 其他命令，那么服务器 并不立即执行 这个命令，而是将 这个命令 放入 一个事务队列里面，然后 向客户端返回 QUEUED 回复。</p>\n<p>MULTI、EXEC、DISCARD、WATCH 这四个指令构成了 redis 事务处理的基础。</p>\n<ul>\n<li><strong>MULTI</strong> 用来组装一个事务。</li>\n<li><strong>EXEC</strong> 用来执行一个事务。</li>\n<li><strong>DISCARD</strong> 用来取消一个事务。</li>\n<li><strong>WATCH</strong> 用来监视一些 key，一旦这些 key 在事务执行之前被改变，则取消事务的执行。</li>\n</ul>\n<h3 id=\"一致性\"><a class=\"anchor\" href=\"#一致性\">#</a> 一致性</h3>\n<p><strong>入队错误</strong></p>\n<ul>\n<li>如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情 况，那么 Redis 将拒绝执行这个事务。</li>\n</ul>\n<p><strong>执行错误</strong><br />\n除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。 关于这种错误有两个需要说明的地方：</p>\n<ul>\n<li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。</li>\n<li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执 行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会 被出错的命令影响。</li>\n</ul>\n<h3 id=\"redis-如何保证原子性\"><a class=\"anchor\" href=\"#redis-如何保证原子性\">#</a> Redis 如何保证原子性</h3>\n<ul>\n<li>Redis 是单线程的，所以 Redis 提供的 API 也是原子操作。</li>\n<li>业务中常常有先 get 后 set 的业务常见，在并发下会导致数据不一致的情况。\n<ul>\n<li>使用 incr、decr、setnx 等原子操作</li>\n<li>使用事务</li>\n<li>使用 Lua 脚本实现 CAS 操作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"watch-命令\"><a class=\"anchor\" href=\"#watch-命令\">#</a> watch 命令</h3>\n<p>很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。Redis 提供了 watch 命令来解决这类问题，这是一种乐观锁的机制。客户端通过 watch 命令，要求服务器对一个或多个 key 进行监视，如果在客户端执行事务之前，这些 key 发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。</p>\n<h2 id=\"缓存\"><a class=\"anchor\" href=\"#缓存\">#</a> 缓存</h2>\n<h3 id=\"如何设计-redis-的过期时间\"><a class=\"anchor\" href=\"#如何设计-redis-的过期时间\">#</a> 如何设计 Redis 的过期时间</h3>\n<ul>\n<li>热点数据不设置过期时间，使其达到「物理」上的永不过期，可以避免缓存击穿问题。</li>\n<li>在设置过期时间时，可以附加一个随机数，避免大量的 key 同时过期，导致缓存雪崩。</li>\n</ul>\n<h3 id=\"缓存错误\"><a class=\"anchor\" href=\"#缓存错误\">#</a> 缓存错误</h3>\n<h4 id=\"缓存穿透\"><a class=\"anchor\" href=\"#缓存穿透\">#</a> 缓存穿透</h4>\n<p><strong>问题描述</strong><br />\n客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。<br />\n<strong>解决方案</strong></p>\n<ul>\n<li><strong>缓存空对象</strong>：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。</li>\n<li><strong>布隆过滤器</strong>：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。</li>\n</ul>\n<h4 id=\"缓存击穿\"><a class=\"anchor\" href=\"#缓存击穿\">#</a> 缓存击穿</h4>\n<p><strong>问题描述</strong><br />\n一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。<br />\n<strong>解决方案</strong></p>\n<ul>\n<li><strong>永不过期</strong>：热点数据不设置过期时间，所以不会出现上述问题，这是 “物理” 上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。</li>\n<li><strong>加互斥锁</strong>：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。</li>\n</ul>\n<h4 id=\"缓存雪崩\"><a class=\"anchor\" href=\"#缓存雪崩\">#</a> 缓存雪崩</h4>\n<p><strong>问题描述</strong><br />\n在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中有大量数据同时过期，也可能是 Redis 节点发生故障，导致大量请求无法得到处理。<br />\n<strong>解决方案</strong></p>\n<ul>\n<li>避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的 key 同时过期。</li>\n<li>启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息 / 空值 / 错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给 Redis ，而是直接返回。</li>\n<li>构建高可用的 Redis 服务：采用哨兵或集群模式，部署多个 Redis 实例，个别节点宕机，依然可以保持服务的整体可用。</li>\n</ul>\n<h2 id=\"分布式锁\"><a class=\"anchor\" href=\"#分布式锁\">#</a> 分布式锁</h2>\n<h3 id=\"基本可用的锁实现\"><a class=\"anchor\" href=\"#基本可用的锁实现\">#</a> 基本可用的锁实现</h3>\n<p><strong>加锁代码</strong></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">acquire_lock</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> lockname<span class=\"token punctuation\">,</span> acquire_timeout<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> lock_timeout<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    identifier <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>uuid<span class=\"token punctuation\">.</span>uuid4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    lockname <span class=\"token operator\">=</span> <span class=\"token string\">\"lock:\"</span> <span class=\"token operator\">+</span> lockname</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    end <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> acquire_timeout</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">while</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">if</span> conn<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span>lockname<span class=\"token punctuation\">,</span> identifier<span class=\"token punctuation\">,</span> ex<span class=\"token operator\">=</span>lock_timeout<span class=\"token punctuation\">,</span> nx<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token keyword\">return</span> identifier</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.001</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></pre></td></tr></table></figure><p><strong>实现锁的关键指令</strong><br />\n <code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code> <br />\n 生存时间（TTL，以秒为单位）<br />\nRedis 2.6.12 版本开始：（等同 SETNX 、 SETEX 和 PSETEX)<br />\n EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br />\nPX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br />\nNX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br />\nXX ：只在键已经存在时，才对键进行设置操作。</p>\n<p>由于 NX 命令的特殊性，可以实现 CAS 的原子操作。</p>\n<p><strong>为什么要设置锁的过期时间</strong><br />\n一个业务进程 A 获取锁之后，如果在释放锁之前宕机，那么在服务端会认为进程 A 一直在持有者这把锁，其它进程将永远获取不到这把锁，导致死锁。设置过期时间后，即使加锁的进程宕机，Redis 服务器也能在过期时间到达时自动释放锁。</p>\n<p><strong>如果锁的过期时间已经到达，业务进程还没有完成业务操作？</strong><br />\n锁的过期时间一般要设置为业务操作时长的两倍，当如果还是有个别业务时需时间较长就需要我们主动续期。在加锁之后将锁放入进程对应的一个锁队列，启动一个线程监测锁的过期时间，在锁即将过期时为锁自动延续过期时间。这种线程一般被叫做「看门狗」线程。</p>\n<p><strong>主从结构锁丢失</strong><br />\n事实上这类琐最大的缺点就是它加锁时只作用在一个 Redis 节点上，即使 Redis 通过 sentinel 保证高可用，如果这个 master 节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p>\n<ul>\n<li>在 Redis 的 master 节点上拿到了锁。</li>\n<li>但是这个加锁的 key 还没有同步到 slave 节点。</li>\n<li>master 故障，发生故障转移，slave 节点升级为 master 节点。</li>\n<li>导致锁丢失。</li>\n</ul>\n<p>正因为如此，Redis 作者 antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock。</p>\n<p><strong>释放锁代码</strong></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">release_lock</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> lockname<span class=\"token punctuation\">,</span> identifier<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">with</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> pipe<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        lockname <span class=\"token operator\">=</span> <span class=\"token string\">'lock:'</span> <span class=\"token operator\">+</span> lockname</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">(</span>lockname<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                <span class=\"token keyword\">if</span> pipe<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>lockname<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> identifier<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>                    pipe<span class=\"token punctuation\">.</span>multi<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                    pipe<span class=\"token punctuation\">.</span>delete<span class=\"token punctuation\">(</span>lockname<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                    pipe<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span>unwatch<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token keyword\">except</span> WatchError<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></pre></td></tr></table></figure><h3 id=\"redlock-实现\"><a class=\"anchor\" href=\"#redlock-实现\">#</a> Redlock 实现</h3>\n<p>antirez 提出的 redlock 算法大概是这样的：</p>\n<p>在 Redis 的分布式环境中，我们假设有 N 个 Redis master。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>。我们确保将在 N 个实例上使用与在 Redis 单实例下相同方法获取和释放锁。现在我们假设有 5 个 Redis master 节点，同时我们需要在 5 台服务器上面运行这些 Redis 实例，这样保证他们不会同时都宕掉。</p>\n<p>为了取到锁，客户端应该执行以下操作：</p>\n<ul>\n<li>获取当前 Unix 时间，以毫秒为单位。</li>\n<li>依次尝试从 5 个实例，使用相同的 key 和具有唯一性的 value（例如 UUID）获取锁。当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个 Redis 实例请求获取锁。</li>\n<li>客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（N/2+1，这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。<br />\n如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</li>\n<li>如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</li>\n</ul>\n<h2 id=\"高可用\"><a class=\"anchor\" href=\"#高可用\">#</a> 高可用</h2>\n<p>所谓的高可用，也叫 HA（High Availability），是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p>\n<h3 id=\"主从模式\"><a class=\"anchor\" href=\"#主从模式\">#</a> 主从模式</h3>\n<p>一般，系统的高可用都是通过部署多台机器实现的。redis 为了避免单点故障，也需要部署多台机器。</p>\n<p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。</p>\n<p>为此，redis 提供了 Redis 提供了复制 (replication) 功能，当一台 redis 数据库中的数据发生了变化，这个变化会被自动的同步到其他的 redis 机器上去。</p>\n<p>redis 多机器部署时，这些机器节点会被分成两类，一类是主节点（master 节点），一类是从节点（slave 节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。同时由于主节点可以写，数据会发生变化，当主节点的数据发生变化时，会将变化的数据同步给从节点，这样从节点的数据就可以和主节点的数据保持一致了。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。</p>\n<h4 id=\"复制机制\"><a class=\"anchor\" href=\"#复制机制\">#</a> 复制机制</h4>\n<ul>\n<li>从数据库连接主数据库，发送 SYNC 命令。</li>\n<li>主数据库接收到 SYNC 命令后，可以执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令。</li>\n<li>主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令。</li>\n<li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照。</li>\n<li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令。</li>\n<li>从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令。（从数据库初始化完成）</li>\n<li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（从数据库初始化完成后的操作）</li>\n<li>出现断开重连后，2.8 之后的版本会将断线期间的命令传给从数据库，增量复制。</li>\n<li>** 主从刚刚连接的时候，进行全量同步。全同步结束后，进行增量同步。** 当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>\n</ul>\n<h3 id=\"哨兵模式\"><a class=\"anchor\" href=\"#哨兵模式\">#</a> 哨兵模式</h3>\n<p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。</p>\n<p>在主从模式下，redis 同时提供了哨兵命令 redis-sentinel，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的 redis 机器发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。</p>\n<p>哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和 redis 机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现 master 宕机哨兵之间会进行决策选举新的 master。</p>\n<p>哨兵集群中哨兵实例之间可以相互发现，基于 Redis 提供的发布 / 订阅机制（pub/sub 机制）,</p>\n<p>哨兵可以在主库中发布 / 订阅消息，在主库上有一个名为 <code>\\__sentinel__:hello</code>  的频道，不同哨兵就是通过它来相互发现，实现互相通信的，而且只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311011140245.png\" alt=\"\" /></p>\n<h4 id=\"哨兵模式的作用\"><a class=\"anchor\" href=\"#哨兵模式的作用\">#</a> 哨兵模式的作用</h4>\n<ul>\n<li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li>\n<li>当哨兵监测到 master 宕机，会自动将 slave 切换到 master，然后通过发布订阅模式通过其他的从服务器，修改配置文件，让它们切换主机。</li>\n<li>然而一个哨兵进程对 Redis 服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</li>\n</ul>\n<h4 id=\"哨兵模式的工作机制\"><a class=\"anchor\" href=\"#哨兵模式的工作机制\">#</a> 哨兵模式的工作机制</h4>\n<ul>\n<li>每个 Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他 Sentinel（哨兵）进程发送一个 PING 命令。</li>\n<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li>\n<li>如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态</li>\n<li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器会被标记为客观下线（ODOWN）</li>\n<li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。</li>\n<li>当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>\n<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master 主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master 主服务器的主观下线状态就会被移除。</li>\n</ul>\n<h3 id=\"集群模式\"><a class=\"anchor\" href=\"#集群模式\">#</a> 集群模式</h3>\n<p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p>\n<p>redis 集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis 集群不需 要 sentinel 哨兵∙也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点 (官方推荐不超过 1000 个节点)。</p>\n<p>根据官方推荐，集群部署至少要 3 台以上的 master 节点，最好使用 3 主 3 从六个节点的模式 。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202311011141538.jpg\" alt=\"\" /></p>\n<h4 id=\"运行机制\"><a class=\"anchor\" href=\"#运行机制\">#</a> 运行机制</h4>\n<ul>\n<li>在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面 redis-trib.rb 执行的结果看到这 16383 个 slot 在三个 master 上的分布。还有一个就是 cluster，可以理解为是一个集群管理的插件，类似的哨兵。</li>\n<li>当我们的存取的 Key 到达的时候，Redis 会根据 crc16 的算法对计算后得出一个结果，然后把结果和 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</li>\n<li>当数据写入到对应的 master 节点后，这个数据会同步给这个 master 对应的所有 slave 节点。</li>\n<li>为了保证高可用，redis-cluster 集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点 ping 主节点 master 1 时，如果半数以上的主节点与 master 1 通信超时，那么认为 master 1 宕机了，就会启用 master 1 的从节点 slave 1，将 slave 1 变成主节点继续提供服务。</li>\n<li>如果 master 1 和它的从节点 slave 1 都宕机了，整个集群就会进入 fail 状态，因为集群的 slot 映射不完整。如果集群超过半数以上的 master 挂掉，无论是否有 slave，集群都会进入 fail 状态。</li>\n<li>redis-cluster 采用去中心化的思想，没有中心节点的说法，客户端与 Redis 节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li>\n</ul>\n",
            "tags": [
                "面试指北",
                "数据库",
                "八股文",
                "数据库",
                "Redis"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/10/28/2023-10-interview-db-mysql/",
            "url": "https://haust-kevin.github.io/2023/10/28/2023-10-interview-db-mysql/",
            "title": "面试指北：MySQL 数据库",
            "date_published": "2023-10-28T06:47:35.000Z",
            "content_html": "<h2 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h2>\n<p>数据库中的事务是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。</p>\n<h3 id=\"acid\"><a class=\"anchor\" href=\"#acid\">#</a> ACID</h3>\n<p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持久性（ Durability ）。这四个特性简称为 ACID 特性。</p>\n<ul>\n<li><strong>原子性（Atomicity）</strong>：一个事务中的多组操作，要么全部成功，要么全部失败。在事务提交（commit）成功之后，所有的操作都生效，提交失败，所有的操作都会回滚。</li>\n<li><strong>一致性（Consistency）</strong>：一个事务执行之前和执行之后数据库都必须处于一致性状态。在事务执行的过程中，只要事务未提交，就不会改变数据库的状态。提交之后事务已完成，此时数据库状态发生变化。</li>\n<li><strong>隔离性（Isolation）</strong>：事务在执行过程中，是与外界完全隔离的，即使数据库发生了变更，事务中也获取不到。A 事务对数据库做的变更，在事务未提交之间，数据库中也看不到，B 事务中也看不到。</li>\n<li><strong>持久性（Durability）</strong>：事务一旦提交，对数据库的变更就会持久化到磁盘，即使数据库发生异常重启，数据也不会丢失。</li>\n</ul>\n<h3 id=\"隔离级别\"><a class=\"anchor\" href=\"#隔离级别\">#</a> 隔离级别</h3>\n<p>SQL 标准定义了 4 类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>\n<ul>\n<li><strong>READ UNCOMMITTED（未提交读）</strong>：事务的修改，即使没有提交，对其他事物也都是可见的。会存在脏读、不可重复读、幻读的问题。</li>\n<li><strong>READ COMMITTED（提交读）</strong>：一个事务从开始直到提交之前，所做的任何修改对其它事物都是不可见的。可以避免脏读问题，但可能存在不可重复读和幻读问题。</li>\n<li><strong>REPEATABLE READ（可重复读）</strong>：同一个事务中多次读取同样记录的结果是一致的。避免了脏读和不可重复读问题，但可能存在幻读问题。Repeatable Read 是 MySQL 默认隔离级别。</li>\n<li><strong>SERIALIZABLE（可串行化）</strong>：最高级别的隔离性，事务串行执行，避免了所有并发问题，可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。</li>\n</ul>\n<h3 id=\"并发问题\"><a class=\"anchor\" href=\"#并发问题\">#</a> 并发问题</h3>\n<p>如果多个事务要是对缓存里的同一条数据同时进行更新或者查询，此时会涉及到脏写、脏读、不可重复读、幻读等问题。<br />\n<strong>脏写</strong>：一个事务去更新了另外一个还没提交的事务更新过的数据。<br />\n<strong>脏读</strong>：一个事务去查询了另外一个还没提交的事务更新过的数据。<br />\n<strong>不可重复读</strong>：在同一个事务中，对于同一组数据读取到的结果不一致。比如，事务 B 在事务 A 提交前读到的结果，和在事务 A 提交后读到的结果可能不同。<br />\n<strong>幻读</strong>：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。</p>\n<h3 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h3>\n<p>死锁是两个或多个事务在同一资源相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。<br />\n<strong>解决</strong>：为了解决这种问题，数据库系统实现了各种死锁检测和超时机制。一般会在检测到死锁后立即返回一个错误。<br />\n死锁的出现有时候是由于存储引擎导致的，而有的则是业务中真正的数据冲突，而且基本无法避免。死锁发生后只有回滚其中的一个事务才能打破死锁。所以程序设计的时候必须考虑如何处理死锁。</p>\n<h3 id=\"mvcc\"><a class=\"anchor\" href=\"#mvcc\">#</a> MVCC</h3>\n<p>MVCC 只在  <code>READ COMMITTED</code>  和  <code>REPEATABLE READ</code>  两个隔离级别下工作。其他两个隔离级别够和 MVCC 不兼容，因为  <code>READ UNCOMMITTED</code>  总是读取最新的数据行，而不是符合当前事务版本的数据行。而  <code>SERIALIZABLE</code>  则会对所有读取的行都加锁。</p>\n<h4 id=\"mvcc-下的-sql-操作\"><a class=\"anchor\" href=\"#mvcc-下的-sql-操作\">#</a> MVCC 下的 SQL 操作</h4>\n<p>InnoDB 的 MVCC ，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号（可以理解为事务的 ID ）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。在  <code>REPEATABLE READ</code>  隔离级别下， MVCC 具体的操作如下：<br />\n<strong>SELECT</strong><br />\nInnoDB 会根据以下两个条件检查每行纪录：</p>\n<ul>\n<li>InnoDB 只查找版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。</li>\n</ul>\n<p>只有符合上述两个条件的纪录，才能作为查询结果返回。</p>\n<p><strong>INSERT</strong><br />\nInnoDB 为插入的每一行保存当前系统版本号作为行版本号。</p>\n<p><strong>DELETE</strong><br />\nInnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</p>\n<p><strong>UPDATE</strong><br />\nInnoDB 为插入一行新纪录，保存当前系统版本号作为行版本号，同时，保存当前系统版本号到原来的行作为行删除标识。</p>\n<h4 id=\"版本链\"><a class=\"anchor\" href=\"#版本链\">#</a> 版本链</h4>\n<p>在 InnoDB 引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>\n<ul>\n<li><strong>trx_id</strong>： 这个 id 用来存储的每次对某条聚簇索引记录进行修改的时候的事务 id。</li>\n<li><strong>roll_pointer</strong>：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入 undo log 中。这个 roll_pointer 就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。（注意插入操作的 undo log 没有这个属性，因为它没有老版本）<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310281653207.png\" alt=\"\" /></li>\n</ul>\n<h4 id=\"readview\"><a class=\"anchor\" href=\"#readview\">#</a> ReadView</h4>\n<p>当我们用 select 读取数据时，这一时刻的数据会有很多个版本（例如上图有四个版本），但我们并不知道读取哪个版本，这时就靠 readview 来对我们进行读取版本的限制，通过 readview 我们才知道自己能够读取哪个版本。</p>\n<h5 id=\"read-view-几个属性\"><a class=\"anchor\" href=\"#read-view-几个属性\">#</a> Read View 几个属性</h5>\n<ul>\n<li>trx_ids: 当前系统活跃（未提交）事务版本号集合。</li>\n<li>low_limit_id: 创建当前 read view 时 “当前系统最大事务版本号 + 1”。</li>\n<li>up_limit_id: 创建当前 read view 时 “系统正处于活跃事务最小版本号”</li>\n<li>creator_trx_id: 创建当前 read view 的事务版本号；</li>\n</ul>\n<h5 id=\"mvcc-如何实现-rc-和-rr-的隔离级别\"><a class=\"anchor\" href=\"#mvcc-如何实现-rc-和-rr-的隔离级别\">#</a> mvcc 如何实现 RC 和 RR 的隔离级别</h5>\n<ul>\n<li>RC 的隔离级别下，每个快照读都会生成并获取最新的 readview。</li>\n<li>RR 的隔离级别下，只有在同一个事务的第一个快照读才会创建 readview，之后的每次快照读都使用的同一个 readview，所以每次的查询结果都是一样的。</li>\n</ul>\n<h2 id=\"索引\"><a class=\"anchor\" href=\"#索引\">#</a> 索引</h2>\n<p>索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一 一对应关系的有序表。</p>\n<p>索引的优点：</p>\n<ul>\n<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以大大加快数据的查询速度，这也是创建索引的主要原因。</li>\n<li>在实现数据的参考完整性方面，可以加速表和表之间的连接。</li>\n<li>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</li>\n</ul>\n<p>索引的缺点：</p>\n<ul>\n<li>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</li>\n<li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>\n</ul>\n<p>索引可以提高查询速度，但是会影响插入记录的速度。因为，向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。</p>\n<h3 id=\"索引结构\"><a class=\"anchor\" href=\"#索引结构\">#</a> 索引结构</h3>\n<h4 id=\"hash\"><a class=\"anchor\" href=\"#hash\">#</a> Hash</h4>\n<p>MySQL 中，只有 Memory 存储引擎支持 Hash 索引，是 Memory 表的默认索引类型。hash 索引把数据的索引以 hash 值形式组织起来，因此检索效率非常高，可以一次定位，不像 B+Tree 索引需要进行从根节点到叶节点的多次 IO 操作。</p>\n<h4 id=\"btree\"><a class=\"anchor\" href=\"#btree\">#</a> B+Tree</h4>\n<p>B+Tree 是 MySQL 使用最频繁的一个索引数据结构，是 Innodb 和 Myisam 存储引擎模式的索引类型。相对 Hash 索引，B+Tree 在查找单条记录的速度比不上 Hash 索引，但是更适合排序等操作。</p>\n<h4 id=\"b-tree-btree\"><a class=\"anchor\" href=\"#b-tree-btree\">#</a> B-Tree &amp; B+Tree</h4>\n<p>B+ 树叶是 m 叉搜索树，在 B 树的基础上，做了一些改进：</p>\n<ul>\n<li>非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；</li>\n<li>叶子之间，增加了链表，获取所有节点，不再需要中序遍历；</li>\n<li>叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；- 非叶子节点存储记录的主键，用于查询加速，适合内存存储；</li>\n<li>非叶子节点，不存储实际记录，而只存储记录的 KEY 的话，那么在相同内存的情况下，B+ 树能够存储更多索引；</li>\n</ul>\n<h3 id=\"myisam-索引\"><a class=\"anchor\" href=\"#myisam-索引\">#</a> MyISAM 索引</h3>\n<p>MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址，MyISAM 索引的原理图如下。这里假设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310281816878.png\" alt=\"\" /><br />\n如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示。同样也是一颗 B+Tree ， data 域保存数据记录的地址。因此， MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310281817570.png\" alt=\"\" /></p>\n<h3 id=\"innodb-索引\"><a class=\"anchor\" href=\"#innodb-索引\">#</a> InnoDB 索引</h3>\n<p>虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。</p>\n<p>第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道， MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p>\n<p>下图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<strong>聚集索引</strong>。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（ MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310281820436.png\" alt=\"\" /><br />\n第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说， InnoDB 的所有辅助索引都引用主键作为 data 域。下图为定义在 Col3 上的一个辅助索引。这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310281821389.png\" alt=\"\" /></p>\n<h3 id=\"创建索引准则\"><a class=\"anchor\" href=\"#创建索引准则\">#</a> 创建索引准则</h3>\n<h4 id=\"应该创建索引的列\"><a class=\"anchor\" href=\"#应该创建索引的列\">#</a> 应该创建索引的列</h4>\n<ul>\n<li>在经常需要搜索的列上，可以加快搜索的速度</li>\n<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>\n<li>在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度</li>\n<li>在经常需要根据范围（&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>\n<li>在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>\n<li>在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。</li>\n</ul>\n<h4 id=\"不该创建索引的列\"><a class=\"anchor\" href=\"#不该创建索引的列\">#</a> 不该创建索引的列</h4>\n<ul>\n<li>在 WHERE 中使用不到的字段，不要设置索引。</li>\n<li>频繁更新的字段不适合建立索引。</li>\n<li>数据比较少的表不需要建索引。</li>\n<li>数据重复且分布比较均匀的的字段不适合建索引，例如性别、真假值。</li>\n<li>参与列计算的列不适合建索引。</li>\n</ul>\n<h3 id=\"索引失效\"><a class=\"anchor\" href=\"#索引失效\">#</a> 索引失效</h3>\n<ul>\n<li>模糊查询 like 以  <code>%</code>  开头；</li>\n<li>在索引字段字段上使用函数</li>\n<li>在索引字段上进行（+，-，*，/，!, !=, &lt;&gt;）等运算，会导致索引失效。</li>\n<li>数据类型隐式转换。<br />\nMySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>\n<li>联合索引没有遵循最左匹配原则。</li>\n<li>在 WHERE 子句中， <code>OR</code>  前后没有同时使用索引。</li>\n<li>优化器选错索引</li>\n</ul>\n",
            "tags": [
                "面试指北",
                "数据库",
                "八股文",
                "数据库",
                "MySQL"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/10/26/2023-10-interview-jvm/",
            "url": "https://haust-kevin.github.io/2023/10/26/2023-10-interview-jvm/",
            "title": "面试指北：Java 虚拟机",
            "date_published": "2023-10-26T07:39:09.000Z",
            "content_html": "<h2 id=\"内存区域\"><a class=\"anchor\" href=\"#内存区域\">#</a> 内存区域</h2>\n<h3 id=\"java-内存区域划分\"><a class=\"anchor\" href=\"#java-内存区域划分\">#</a> Java 内存区域划分</h3>\n<p>Java 虚拟机规范规定的区域分为以下 5 个部分：</p>\n<ul>\n<li><strong>程序计数器（Program Counter Register）</strong>：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>\n<li><strong>Java 虚拟机栈（Java Virtual Machine Stacks）</strong>：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>\n<li><strong>本地方法栈（Native Method Stack）</strong>：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>\n<li><strong>Java 堆（Java Heap）</strong>：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>\n<li><strong>方法区（Methed Area）</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br />\n<img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690687338/9602C6323C6B86C4EDA164DB052D8420\" alt=\"\" /></li>\n</ul>\n<h4 id=\"本地内存\"><a class=\"anchor\" href=\"#本地内存\">#</a> 本地内存</h4>\n<p>Java 虚拟机在执行的时候会把管理的内存分配成不同的区域，这些区域被称为虚拟机内存，同时，对于虚拟机没有直接管理的物理内存，也有一定的利用，这些被利用却不在虚拟机内存数据区的内存，我们称它为本地内存。<br />\n本地内存不受虚拟机内存参数的限制，只受物理内存容量的限制。<br />\n虽然不受参数的限制，但是如果内存的占用超出物理内存的大小，同样也会报 OOM。</p>\n<p><strong>元空间</strong><br />\n在 Java1.8 中，HotSpot 虚拟机已经将方法区（永久带）移除，取而代之的就是元空间。元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p>\n<p><strong>直接内存</strong></p>\n<ul>\n<li>直接内存不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。</li>\n<li>直接内存是在 Java 堆外的、直接向系统申请的内存空间。</li>\n<li>来源于 NIO ，通过存在堆中的 DirectByteBuffer 操作 Native 内存。</li>\n<li>通常，访问直接内存的速度会优于 Java 堆，即读写性能高。因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存。Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区。</li>\n</ul>\n<h4 id=\"主内存和本地内存的关系\"><a class=\"anchor\" href=\"#主内存和本地内存的关系\">#</a> 主内存和本地内存的关系</h4>\n<p>JMM 规定的主内存和本地内存的关系</p>\n<ul>\n<li>所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中所有的变量内容都是主内存的拷贝。</li>\n<li>线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，再同步到主内存中。即在修改变量之前，要先执行第一步规定的，把数据拷贝到工作内存中再修改，再同步。</li>\n<li>主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成。</li>\n</ul>\n<p><strong>总结</strong>：所有的共享变量，是存在于主内存中的，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，正是由于有交换的过程，并且这个交换不是实时的，所以才导致了可见性的问题。<strong>volatile</strong> 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p>\n<h3 id=\"对象内存布局\"><a class=\"anchor\" href=\"#对象内存布局\">#</a> 对象内存布局</h3>\n<p>Java 对象保存在堆中时，由以下三部分组成：</p>\n<ul>\n<li><strong>对象头（object header）</strong>：包括了关于堆对象的布局、类型、GC 状态、同步状态和标识哈希码的基本信息。Java 对象和 vm 内部对象都有一个共同的对象头格式。</li>\n<li><strong>实例数据（Instance Data）</strong>：主要是存放类的数据信息，父类的信息，对象字段属性信息。</li>\n<li><strong>对齐填充（Padding）</strong>：为了字节对齐，填充的数据，不是必须的。</li>\n</ul>\n<p>对象头包括两部分：<strong>Mark Word</strong>, <strong>Klass pointer</strong></p>\n<h4 id=\"mark-word\"><a class=\"anchor\" href=\"#mark-word\">#</a> Mark Word</h4>\n<p>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p>\n<p>Mark Word 在不同的锁状态下存储的内容不同，在 64 位 JVM 中是这么存的<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310261655824.png\" alt=\"\" /></p>\n<p><strong>锁标志位（lock）</strong>：区分锁状态，11 时表示对象待 GC 回收状态，只有最后 2 位锁标识 (11) 有效。<br />\n<strong>是否偏向（biased_lock）</strong>：是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。<br />\n<strong>分代年龄（age）</strong>：表示对象被 GC 的次数，当该次数到达阈值的时候，对象就会转移到老年代。<br />\n<strong>对象的 hashcode（hash）</strong>：运行期间调用 System.identityHashCode () 来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果 31 位不够表示，在偏向锁，轻量锁，重量锁，hashcode 会被转移到 Monitor 中。<br />\n<strong>偏向锁的线程 ID（JavaThread）</strong>：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的 ID。 在后面的操作中，就无需再进行尝试获取锁的动作。<br />\n<strong>epoch</strong>：偏向锁的时间戳。<br />\n<strong>ptr_to_lock_record</strong>：轻量级锁状态下，指向栈中锁记录的指针。锁记录存储的是所之前锁对象的 Mark Word 的拷贝。<br />\n<strong>ptr_to_heavyweight_monitor</strong>：重量级锁状态下，指向对象监视器 Monitor 的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到 Monitor 以管理等待的线程。在重量级锁定的情况下，JVM 在对象的 ptr_to_heavyweight_monitor 设置指向 Monitor 的指针。</p>\n<h4 id=\"数据对齐\"><a class=\"anchor\" href=\"#数据对齐\">#</a> 数据对齐</h4>\n<p>字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</p>\n<h3 id=\"偏向锁\"><a class=\"anchor\" href=\"#偏向锁\">#</a> 偏向锁</h3>\n<h4 id=\"锁撤销\"><a class=\"anchor\" href=\"#锁撤销\">#</a> 锁撤销</h4>\n<p>撤销偏向锁就是将锁对象 oop 的对象头恢复成无锁状态或者膨胀成轻量级锁状态，执行撤销动作的前提是锁对象 oop 的对象头处于偏向锁状态。<br />\n<strong>锁撤销过程</strong><br />\n尝试获取某个偏向锁，如果该偏向锁被某个线程占用了，但是没有关联的 BasicObjectLock ，即实际占用该偏向锁的方法已经退出了，则会将其恢复成无锁状态，然后膨胀成轻量级锁，但是在撤销一定次数后触发批量重偏向（rebasic）的情形下也可能重新获取该偏向锁。如果该偏向锁正在被某个方法所使用，即存在对应的 BasicObjectLock ，则直接将该偏向锁膨胀成轻量级锁。</p>\n<p>在已偏向后调用 Object.hashCode () 方法时，锁定状态下，锁膨胀为重量级锁；非锁定状态下，锁会恢复为无锁状态。</p>\n<h4 id=\"批量重偏向\"><a class=\"anchor\" href=\"#批量重偏向\">#</a> 批量重偏向</h4>\n<p>避免短时间内大量偏向锁的撤销。例如一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。当执行批量重偏向后，如果原偏向锁持有者线程不再执行同步块，则锁可以偏向于新线程。<br />\n以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，每一次该 class 的对象发生偏向撤销操作时，该计数器 +1，当这个值达到重偏向阈值（默认 20 ）时， JVM 就认为该 class 的偏向锁有问题，因此会进行批量重偏向。每个 class 对象会有一个对应的 epoch 字段，每个处于偏向锁状态对象的 mark word 中也有该字段，其初始值为创建该对象时，class 中的 epoch 的值。每次发生批量重偏向时，就将该值 +1，同时遍历 JVM 中所有线程的栈，找到该 class 所有正处于加锁状态的偏向锁，将其 epoch 字段改为新值。下次获得锁时，发现当前对象的 epoch 值和 class 的 epoch 不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过 CAS 操作将其 mark word 的 Thread Id 改成当前线程 Id。</p>\n<h4 id=\"批量锁撤销\"><a class=\"anchor\" href=\"#批量锁撤销\">#</a> 批量锁撤销</h4>\n<p>当一个偏向锁如果撤销次数到达 40 的时候就认为这个对象设计的有问题；那么 JVM 会把这个对象所对应的类所有的对象都撤销偏向锁；并且新实例化的对象也是不可偏向的。</p>\n<h4 id=\"对象计算过哈希值之后还能进入偏向锁状态吗\"><a class=\"anchor\" href=\"#对象计算过哈希值之后还能进入偏向锁状态吗\">#</a> 对象计算过哈希值之后还能进入偏向锁状态吗</h4>\n<ul>\n<li>当一个对象已经计算过 identity hashcode，它就无法进入偏向锁状态；</li>\n<li>当一个对象当前正处于偏向锁状态，并且需要计算其 identity hashcode 的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li>\n<li>重量锁的实现中，ObjectMonitor 类里有字段可以记录非加锁状态下的 mark word ，其中可以存储 identity hash code 的值。或者简单说就是重量锁可以存下 identity hash code。</li>\n</ul>\n<p>Identity hash code 是未被覆写的 java.lang.Object.hashCode ()</p>\n<h2 id=\"类文件结构\"><a class=\"anchor\" href=\"#类文件结构\">#</a> 类文件结构</h2>\n<p><strong>class 文件格式</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>名称</th>\n<th>数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u4</td>\n<td>magic</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>minor_version</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>major_version</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>constant_pool_count</td>\n<td>1</td>\n</tr>\n<tr>\n<td>cp_info</td>\n<td>constant_pool</td>\n<td>constant_pool_count  - 1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>access_flags</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>this_class</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>super_class</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>interfaces_count</td>\n<td>1</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>interfaces</td>\n<td>interfaces_count</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>fields_count</td>\n<td>1</td>\n</tr>\n<tr>\n<td>field_info</td>\n<td>fields</td>\n<td>fields_count</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>methods_count</td>\n<td>1</td>\n</tr>\n<tr>\n<td>method_info</td>\n<td>methods</td>\n<td>methods_count</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>attribute_count</td>\n<td>1</td>\n</tr>\n<tr>\n<td>attribute_info</td>\n<td>attributes</td>\n<td>attributes_count</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"类加载机制\"><a class=\"anchor\" href=\"#类加载机制\">#</a> 类加载机制</h2>\n<h3 id=\"类的生命周期\"><a class=\"anchor\" href=\"#类的生命周期\">#</a> 类的生命周期</h3>\n<p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310271600947.png\" alt=\"类的生命周期\" /></p>\n<h3 id=\"类加载时期\"><a class=\"anchor\" href=\"#类加载时期\">#</a> 类加载时期</h3>\n<p>在什么情况下需要开始类加载过程的第一个阶段「加载」，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。<br />\n<strong>类初始化时期</strong><br />\n对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行「初始化」（而加载、验证、准备自然需要在此之前开始）：</p>\n<ol>\n<li>遇到 new（用 new 实例对象），getStatic（读取一个静态字段），putstatic（设置一个静态字段），invokeStatic（调用一个类的静态方法）这四条指令字节码命令时。</li>\n<li>使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main () 方法的那个类），虚拟机会先初始化这个主类。</li>\n<li>当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n</ol>\n<p><strong>下面这几种情况就不会触发类初始化：</strong></p>\n<ul>\n<li>通过子类调用父类的静态字段。此时父类符合情况一，而子类不符合任何情况。所以只有父类被初始化。</li>\n<li>通过数组来引用类，不会触发类的初始化。因为 new 的是数组，而不是类。</li>\n<li>调用类的静态常量不会触发类的初始化，因为静态常量在编译阶段就会被存入调用类的常量池中，不会引用到定义常量的类。</li>\n</ul>\n<h3 id=\"类加载器\"><a class=\"anchor\" href=\"#类加载器\">#</a> 类加载器</h3>\n<p>在 JDK1.8 及之前的版本中中，类加载器主要有下面四种：<br />\nBootstrapClassLoader：启动类加载器，使用 C++ 实现；<br />\nExtClassLoader：扩展类加载器，使用 Java 实现；<br />\nAppClassLoader：应用程序类加载器，加载当前应用的 classpath 的所有类；<br />\nUserDefinedClassLoader：用户自定义类加载器；</p>\n<h3 id=\"双亲委派\"><a class=\"anchor\" href=\"#双亲委派\">#</a> 双亲委派</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">protected</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// First, check if the class has already been loaded</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                    c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                    c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                <span class=\"token comment\">// ClassNotFoundException thrown if class not found</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token comment\">// from the non-null parent class loader</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                <span class=\"token comment\">// If still not found, then invoke findClass in order</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token comment\">// to find the class.</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"为什么要双亲委派\"><a class=\"anchor\" href=\"#为什么要双亲委派\">#</a> 为什么要双亲委派</h4>\n<ul>\n<li><strong>避免重复加载</strong>：使用双亲委派模型也可以避免一个类被重复加载，当一个类被加载之后，因为使用的双亲委派模型，这样不会出现多个类加载器都将同一个类重复加载的情况了。</li>\n<li><strong>安全</strong>：当使用双亲委派模型时，用户就不能伪造一些不安全的系统类了，比如 jre 里面已经提供了 String 类在启动类加载时加载，那么用户自定义再自定义一个不安全的 String 类时，按照双亲委派模型就不会再加载用户定义的那个不安全的 String 类了，这样就可以避免非安全问题的发生了。</li>\n</ul>\n<h4 id=\"破坏双亲模型\"><a class=\"anchor\" href=\"#破坏双亲模型\">#</a> 破坏双亲模型</h4>\n<p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式。这个委派和加载顺序完全是可以被破坏的。<br />\n如果想自定义类加载器，就需要继承 ClassLoader ，并重写 findClass ，如果想不遵循双亲委派的类加载顺序，还需要重写 loadClass 。<br />\n<strong>JDBC 打破双亲模型</strong><br />\n在双亲委托模型下，类加载器是由下至上的，即下层的类加载器会委托上层进行加载。但是对于 SPI 来说，有些接口是 JAVA 核心库提供的，而 Java 核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的 jar 包（厂商提供）， Java 的启动类加载器是不会加载其他来源的 jar 包，这样传统的双亲委托模型就无法满足 SPI 的要求。而通过给当前线程设置上下文类加载器，就可以通过设置的上下文类加载器来实现对于接口实现类的加载。<br />\n线程上下文类加载器是从 jdk1.2 开始引入的，类 Thread 中的 getContextClassLoader () 与 setContextClassLoader (ClassLoader c1)，分别用来获取和设置类加载器。</p>\n<h2 id=\"自动内存管理吗\"><a class=\"anchor\" href=\"#自动内存管理吗\">#</a> 自动内存管理吗</h2>\n<h3 id=\"对象何时死亡\"><a class=\"anchor\" href=\"#对象何时死亡\">#</a> 对象何时死亡</h3>\n<h4 id=\"引用计数算法\"><a class=\"anchor\" href=\"#引用计数算法\">#</a> 引用计数算法</h4>\n<p>算法会在每一个对象上记录这个对象被引用的次数，只要有任何一个对象引用了次对象，这个对象的计数器就 +1 ，取消对这个对象的引用时，计数器就 -1 。任何一个时刻，如果该对象的计数器为 0 ，那么这个对象就是可以回收的。<br />\n<strong>缺点</strong>：1. 无法处理循环引用的情况；2. 堆内对象的每一次引用赋值和每一次引用清除，都伴随着加减法的操作，会带来一定的性能开销。</p>\n<h4 id=\"可达性分析算法\"><a class=\"anchor\" href=\"#可达性分析算法\">#</a> 可达性分析算法</h4>\n<p>现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，可达性算法的原理是以一系列叫做  GC Root  的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕，如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为垃圾对象，会被 GC 回收。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310271720872.png\" alt=\"可达性分析算法\" /></p>\n<h4 id=\"垂死挣扎\"><a class=\"anchor\" href=\"#垂死挣扎\">#</a> 垂死挣扎</h4>\n<p><strong>对象可回收，就一定会被回收吗</strong><br />\n对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生 GC 时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！<br />\nfinalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记！</p>\n<h4 id=\"gc-roots\"><a class=\"anchor\" href=\"#gc-roots\">#</a> GC Roots</h4>\n<p><strong>可以作为 GC Roots 的对象</strong></p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。</li>\n<li>方法区中类静态属性引用的对象；java 类的引用类型静态变量。</li>\n<li>方法区中常量引用的对象；比如：字符串常量池里的引用。</li>\n<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>\n<li>JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。（非重点）</li>\n<li>所有被同步锁 (synchronized 关键）持有的对象。（非重点）</li>\n<li>JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。（非重点）</li>\n<li>JVM 实现中的「临时性」对象，跨代引用的对象（在使用分代模型回收只回收部分代的对象）。（非重点）</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a class=\"anchor\" href=\"#垃圾收集算法\">#</a> 垃圾收集算法</h3>\n<h4 id=\"分代收集理论\"><a class=\"anchor\" href=\"#分代收集理论\">#</a> 分代收集理论</h4>\n<p><strong>弱分代假说</strong>：绝大多数对象，在第一次垃圾收集时就会被回收。<br />\n<strong>强分代假说</strong>：熬过越多次收集过程的对象越难以消亡。<br />\n这两种假说给我们提供了一种设计思想就是将 java 堆划分出不同的区域，别急我们慢慢来说明一下：根据弱分代理论呢，如果有专门一块区域的绝大多数对象都是「脆弱」的，那每次回收时就只关注少量存活就好了，就可以以较少的代价回收到大量空间。那根据强理论呢，如果有专门一块区域的绝大多数对象都是「顽固」的，那虚拟机就可以以较低的频率进行垃圾回收，这就提高了内存的利用率。</p>\n<p><strong>跨代引用假说</strong>：跨代引用相对于同代引用来说仅占极少数。<br />\n该假说认为只会存在很少的跨代引用。因为只要经过一些次数的垃圾收集，即使还存在跨代引用，新生代会变成老年代，跨代引用也就自然消失了，所以跨代引用的数量不会多。在对新生代对象进行收集时，由于可能存在老年代对象引用了该对象，那么，需要找到这些老年代对象。根据跨代引用假说，这些跨代引用的数量不会太多，相比于对老年代进行扫描，在新生代建立一个全局数据结构，记录哪一块老年代内存会存在跨代引用，虽然维护这个数据结构，也需要少量的开销。但仍然显得更加合算。</p>\n<p>基于这个分代假设，一般的垃圾回收器把内存分成三类：Eden (E), Suvivor (S) 和 Old (O), 其中 Eden 和 Survivor 都属于年轻代， Old 属于老年代，新对象始终分配在 Eden 里面，熬过一次垃圾回收的对象就被移动到 Survivor 区了，经过数次垃圾回收之后还活着的对象会被移到 Old 区。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310272158264.png\" alt=\"\" /></p>\n<p><strong>收集方式</strong><br />\n Java 堆分为新生代和老年代，针对收集对象处于哪一代，一共有以下四种收集方式。</p>\n<ul>\n<li>部分收集\n<ul>\n<li>新生代收集 (Minor GC / Young GC)，只收集新生代垃圾对象</li>\n<li>老年代收集 (Major GC / Old GC)，只收集老年代垃圾对象，目前只有 CMS 收集器会单独收集老年代对象。需要注意的是，Major GC，目前这个说法有点混淆，有时候专指老年代收集，有时候指的是整堆收集（Full GC）。</li>\n<li>混合收集 (Mixed GC)，收集来自整个新生代以及部分老年代中的垃圾对象。目前只有 G1 会有这种行为。</li>\n</ul>\n</li>\n<li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li>\n</ul>\n<h4 id=\"标记-清除算法\"><a class=\"anchor\" href=\"#标记-清除算法\">#</a> 标记 - 清除算法</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310272226947.png\" alt=\"\" /><br />\n<strong>原理</strong>：分为标记和清除两个阶段：标记阶段和清除阶段。标记过程中，将活动对象的标记位设置为有效状态，表示这些对象是可达的，不会被回收。将未被标记的对象视为垃圾对象，将其所占用的内存空间释放，以便下次分配给新的对象使用。<br />\n<strong>缺点</strong>：</p>\n<ol>\n<li>会产生大量内存碎片，空间不连续后面有大对象时无法使用，可能会引起一次垃圾回收</li>\n<li>标记和清除两个过程都比较耗时，效率不高</li>\n</ol>\n<h4 id=\"标记-复制算法\"><a class=\"anchor\" href=\"#标记-复制算法\">#</a> 标记 - 复制算法</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310272227689.png\" alt=\"\" /><br />\n<strong>原理</strong>：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。<br />\n<strong>缺点</strong>：</p>\n<ol>\n<li>解决了标记 - 清除算法中清除慢的问题，但是空间利用率低。</li>\n<li>在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都有 100% 存活的极端情况。</li>\n</ol>\n<h4 id=\"标记-整理算法\"><a class=\"anchor\" href=\"#标记-整理算法\">#</a> 标记 - 整理算法</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310272228578.png\" alt=\"\" /><br />\n<strong>原理</strong>：该算法标记阶段和 Mark-Sweep 一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。<br />\n<strong>缺点</strong>：同标记复制算法，由于整理牵扯到了对象的移动，效率会变得较低。</p>\n<h4 id=\"并发的可达性分析\"><a class=\"anchor\" href=\"#并发的可达性分析\">#</a> 并发的可达性分析</h4>\n<ul>\n<li>白色：\n<ul>\n<li>表示对象尚未被垃圾收集器访问过。</li>\n<li>可达性分析开始前，所有对象都是白色的，如果分析结束后，依然是白色的对象，意味着它是不可达的，将会被回收。</li>\n</ul>\n</li>\n<li>黑色：\n<ul>\n<li>表示对象已经被垃圾收集器访问过，而且对象的引用链已经遍历完成。</li>\n<li>黑色的对象，意味着它是可达的，不会被回收。</li>\n<li>如果被其他对象引用，不需要重新遍历一遍。</li>\n<li>黑色的对象不可能直接（不经过灰色的对象）指向某个白色的对象。</li>\n</ul>\n</li>\n<li>灰色：\n<ul>\n<li>表示对象已经被垃圾回收器访问过，但是对象的引用链没有遍历完成。</li>\n<li>灰色的对象在黑色的对象和白色的对象之间。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"浮动垃圾\"><a class=\"anchor\" href=\"#浮动垃圾\">#</a> 浮动垃圾</h5>\n<p>并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描，所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从 GC Root 中去找到，所以成为了浮动垃圾，浮动垃圾对系统的影响不大，留给下一次 GC 进行处理即可。</p>\n<h5 id=\"对象丢失\"><a class=\"anchor\" href=\"#对象丢失\">#</a> 对象丢失</h5>\n<p><strong>对象消失需要满足的条件</strong>：</p>\n<ul>\n<li>插入一条或多条从黑色对象到白色对象的新引用</li>\n<li>删除全部从灰色对象到该白色对象的直接或间接引用</li>\n</ul>\n<p><strong>对象消失示意图</strong><br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310271901281.png\" alt=\"\" /><br />\n<strong>解决方案</strong><br />\n解决并发扫描时的对象消失问题，只需要破化以上两个条件的其中一个即可。因此产生两种解决方案：</p>\n<ul>\n<li><strong>增量更新</strong>：破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</li>\n<li><strong>原始快照</strong>：破化的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</li>\n</ul>\n<p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的，且以上两种方案在垃圾收集器中都有实际使用如：CMS 是基于增量更新来做并发标记；G1、Shenandoah 则是使用原始快照来实现的。</p>\n<h3 id=\"经典垃圾收集器\"><a class=\"anchor\" href=\"#经典垃圾收集器\">#</a> 经典垃圾收集器</h3>\n<h4 id=\"cms\"><a class=\"anchor\" href=\"#cms\">#</a> CMS</h4>\n<p>Concurrent Mark Sweep，采用标记 - 清除算法，用于老年代，常与 ParNew 协同工作。优点在于并发收集与低停顿。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310272053797.png\" alt=\"\" /></p>\n<h5 id=\"步骤\"><a class=\"anchor\" href=\"#步骤\">#</a> 步骤</h5>\n<p><strong>初始标记</strong>：这个过程十分快速，需要 stop the world，遍历所有的对象并且标记初始的 GC Roots。<br />\n<strong>并发标记</strong>：这个过程可以和用户线程一起并发完成，所以对于系统进程的影响较小，主要的工作为在系统线程运行的时候通过 GC Roots 对于对象进行根节点枚举的操作，标记对象是否存活，注意这里的标记也是较为迅速和简单的，因为下一步还需要重新标记。<br />\n<strong>重新标记</strong>：需要 stop the world，用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象（使用增量更新方式），时间短。<br />\n<strong>并发清理</strong>：和用户线程一起并发，清除那些没有标记的对象并且回收空间。<br />\nCMS 使用 增量更新的方式解决「对象消失」的问题。</p>\n<h5 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点</h5>\n<ul>\n<li>对 CPU 资源太敏感，虽然在并发标记阶段用户线程没有暂停，但是由于收集器占用了一部分 CPU 资源，导致程序的响应速度变慢。</li>\n<li>无法处理浮动垃圾。原因在于 CMS 是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间，只好在下一次 GC 的时候处理。有可能出现「Con-current Mode Failure」失败进而导致另一次完全「Stop The World」的 Full GC 的产生。</li>\n<li>由于 CMS 收集器是基于「标记 - 清除」算法的，前面说过这个算法会导致大量的空间碎片的产生，一旦空间碎片过多，大对象就没办法给其分配内存，那么即使内存还有剩余空间容纳这个大对象，但是却没有连续的足够大的空间放下这个对象，所以虚拟机就会触发一次 Full GC。Full GC 会进行一次碎片整理。</li>\n</ul>\n<h4 id=\"g1-garbage-first\"><a class=\"anchor\" href=\"#g1-garbage-first\">#</a> G1 (Garbage First)</h4>\n<p>通过把 Java 堆分成大小相等的多个独立区域，回收时计算出每个区域回收所获得的空间以及所需时间的经验值，根据记录两个值来判断哪个区域最具有回收价值，所以叫 Garbage First（垃圾优先）。G1 收集器与之前的收集器最大的不同就在于堆内存的划分，之前的收集器只区分新生代与老年代，而 G1 收集器则是把堆内存划分成多个独立的 Region 。<br />\n<img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310272109199.png\" alt=\"\" /></p>\n<h5 id=\"步骤-2\"><a class=\"anchor\" href=\"#步骤-2\">#</a> 步骤</h5>\n<p><strong>初始标记</strong>：这个阶段是 STW (Stop the World) 的，所有应用线程会被暂停，标记出从 GC Root 开始直接可达的对象。</p>\n<p><strong>并发标记</strong>：从 GC Roots 开始，对堆中对象进行可达性分析，找出存活对象，耗时较长。<br />\n<strong>最终标记</strong>：标记那些在并发标记阶段发生变化的对象（使用原始快照方式），将被回收。<br />\n<strong>筛选回收</strong>：首先，对各个 Regin 的回收价值和成本进行排序，根据用户所期待的 GC 停顿时间，来指定回收计划，回收一部分 Region 。</p>\n<p>G1 中提供了 Young GC、Mixed GC 两种垃圾回收模式，这两种垃圾回收模式，都是 Stop The World (STW) 的。</p>\n<h5 id=\"回收模式\"><a class=\"anchor\" href=\"#回收模式\">#</a> 回收模式</h5>\n<p><strong>Young GC</strong><br />\n 在分配一般对象（非巨型对象）时，当所有 eden region 使用达到最大阀值、并且无法申请足够内存时，会触发一次 YoungGC 。<br />\n每次 young gc 会回收所有 Eden 、以及 Survivor 区，并且将存活对象复制到 Old 区以及另一部分的 Survivor 区。</p>\n<p><strong>Mixed GC</strong><br />\n 当越来越多的对象晋升到老年代 old region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集，即 mixed gc ，该算法并不是一个 old gc ，除了回收整个 young region ，还会回收一部分的 old region 。</p>\n<p><strong>巨型对象</strong><br />\n G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，主要用于存储大对象，如果超过 1.5 个 region , 就放到 Humongous 区域。</p>\n<h5 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h5>\n<p>G1 的一个显著特点他能够让用户设置应用的暂停时间，G1 回收的第 4 步，它是「选择一些内存块」，而不是整代内存来回收，这是 G1 跟其它 GC 非常不同的一点，其它 GC 每次回收都会回收整个 Generation 的内存 (Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而 G1 每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。</p>\n",
            "tags": [
                "面试指北",
                "Java",
                "八股文",
                "Java",
                "JVM"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/10/25/2023-10-interview-Java-basic/",
            "url": "https://haust-kevin.github.io/2023/10/25/2023-10-interview-Java-basic/",
            "title": "面试指北：Java 基础",
            "date_published": "2023-10-25T11:34:51.000Z",
            "content_html": "<h2 id=\"面向对象\"><a class=\"anchor\" href=\"#面向对象\">#</a> 面向对象</h2>\n<h3 id=\"面向对象的三大特征\"><a class=\"anchor\" href=\"#面向对象的三大特征\">#</a> 面向对象的三大特征</h3>\n<p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态。<br />\n<strong>封装</strong>指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；<br />\n<strong>继承</strong>是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；<br />\n<strong>多态</strong>指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。</p>\n<h2 id=\"java-基础\"><a class=\"anchor\" href=\"#java-基础\">#</a> Java 基础</h2>\n<h3 id=\"string-stringbuilder-stringbuffer\"><a class=\"anchor\" href=\"#string-stringbuilder-stringbuffer\">#</a> String &amp; StringBuilder &amp; StringBuffer</h3>\n<p><code>String</code>  类是不可变类，即一旦一个 <code>String</code>  对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。<br />\n <code>StringBuffer</code> 、 <code>StringBuilder</code>  都代表可变的字符串对象，它们有共同的父类  <code>AbstractStringBuilder</code> ，并且两个类的构造方法和成员方法也基本相同。不同的是， <code>StringBuffer</code>  是线程安全的，而 <code>StringBuilder</code>  是非线程安全的，所以 <code>StringBuilder</code>  性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑 <code>StringBuilder</code>  类。</p>\n<h3 id=\"java-中str-hello和str-new-stringhello两种创建字符串的区别\"><a class=\"anchor\" href=\"#java-中str-hello和str-new-stringhello两种创建字符串的区别\">#</a> Java 中 <code>str = &quot;hello&quot;</code>  和 <code>str = new String(&quot;hello')</code>  两种创建字符串的区别</h3>\n<p>当 Java 程序直接使用  <code>&quot;hello&quot;</code>  的字符串直接量时，JVM 会使用常量池来管理字符串直接量 （在执行这句话时，JVM 会先检查常量池中是否已经存有  <code>&quot;hello&quot;</code> ，若没有则将  <code>&quot;hello&quot;</code>  存入常量池，否则就复用常量池中已有的  <code>&quot;hello&quot;</code> ，将其引用赋值给变量 str。）。</p>\n<p>当使用  <code>new String(&quot;hello&quot;)</code>  时，JVM 会先使用常量池来管理  <code>&quot;hello&quot;</code>  字符串直接量，再调用 String 类的构造器来创建一个新的 String 对象，新创建的 String 对象被保存在堆内存中。并且，堆中对象的数据会指向常量池中的直接量。</p>\n<h3 id=\"java-创建对象的方式\"><a class=\"anchor\" href=\"#java-创建对象的方式\">#</a> Java 创建对象的方式</h3>\n<ol>\n<li>使用 new 关键字</li>\n<li>使用 Class 类的 newInstance () 方法：\n<ol>\n<li>使用 Class 类的 forName () 方法</li>\n<li>使用 ClassLoader 类的 loadClass () 方法</li>\n</ol>\n</li>\n<li>使用 Constructor 类的 newInstance () 方法</li>\n<li>使用 clone () 方法</li>\n<li>使用反序列化</li>\n</ol>\n<h3 id=\"两个字符串相加的底层实现\"><a class=\"anchor\" href=\"#两个字符串相加的底层实现\">#</a> 两个字符串相加的底层实现</h3>\n<p>如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。<br />\n如果拼接的字符串中包含变量，则在编译时编译器采用 StringBuilder 对其进行优化，即自动创建 StringBuilder 实例并调用其 append () 方法，将这些字符串拼接在一起。</p>\n<h3 id=\"java-的异常接口\"><a class=\"anchor\" href=\"#java-的异常接口\">#</a> Java 的异常接口</h3>\n<p>Throwable 是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是 Error、Exception。</p>\n<ul>\n<li><code>Error</code>  是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用 catch 块来捕获 Error 对象。在定义方法时，也无须在其 throws 子句中声明该方法可能抛出 Error 及其任何子类。</li>\n<li><code>Exception</code>  是异常，它被分为两大类，分别是 Checked 异常和 Runtime 异常。\n<ul>\n<li><code>RuntimeException</code>  （不受检异常）： RuntimeException 类及其子类表示 JVM 在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li>\n<li><code>CheckedException</code>  （受检异常）： Exception 中除 RuntimeException 及其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说 IOException ，必须对该异常进行处理，要么使用 <code>try-catch</code>  捕获，要么使用 throws 语句抛出，否则编译不通过。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"java-对象的四种引用方式\"><a class=\"anchor\" href=\"#java-对象的四种引用方式\">#</a> Java 对象的四种引用方式</h3>\n<p>Java 对象的四种引用方式分别是强引用、软引用、弱引用、虚引用，具体含义如下：</p>\n<ul>\n<li><strong>强引用</strong>：这是 Java 程序中最常见的引用方式，即程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。</li>\n<li><strong>软引用</strong>：当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象。当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。</li>\n<li><strong>弱引用</strong>：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。</li>\n<li><strong>虚引用</strong>：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。</li>\n</ul>\n<h2 id=\"容器类型\"><a class=\"anchor\" href=\"#容器类型\">#</a> 容器类型</h2>\n<h3 id=\"java-中有哪些容器\"><a class=\"anchor\" href=\"#java-中有哪些容器\">#</a> Java 中有哪些容器</h3>\n<p>Java 中的集合类主要由 <code>Collection</code>  和 <code>Map</code>  这两个接口派生而出，其中 <code>Collection</code>  接口又派生出三个子接口，分别是 <code>Set</code> 、 <code>List</code> 、 <code>Queue</code> 。所有的 Java 集合类，都是 <code>Set</code> 、 <code>List</code> 、 <code>Queue</code> 、 <code>Map</code>  这四个接口的实现类，这四个接口将集合分成了四大类，其中</p>\n<ul>\n<li><code>Set</code>  代表无序的，元素不可重复的集合；</li>\n<li><code>List</code>  代表有序的，元素可以重复的集合；</li>\n<li><code>Queue</code>  代表先进先出（FIFO）的队列；</li>\n<li><code>Map</code>  代表具有映射关系（key-value）的集合。</li>\n</ul>\n<h3 id=\"java-中容器的线程安全性\"><a class=\"anchor\" href=\"#java-中容器的线程安全性\">#</a> Java 中容器的线程安全性</h3>\n<p>java.util 包下的集合类大部分都是线程不安全的，例如我们常用的 HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap，这些都是线程不安全的集合类，但是它们的优点是性能好。如果需要使用线程安全的集合类，则可以使用 <code>Collections</code>  工具类提供的 <code>synchronizedXxx()</code>  方法，将这些集合类包装成线程安全的集合类。</p>\n<p>java.util 包下也有线程安全的集合类，例如 Vector、Hashtable 。这些集合类都是比较古老的 API ，虽然实现了线程安全，但是性能很差。所以即便是需要使用线程安全的集合类，也建议将线程不安全的集合类包装成线程安全集合类的方式，而不是直接使用这些古老的 API 。</p>\n<p>从 Java5 开始，Java 在 java.util.concurrent 包下提供了大量支持高效并发访问的集合类，它们既能保证良好的访问性能，又能保证线程安全。这些集合类可以分为两部分，它们的特征如下：</p>\n<ul>\n<li>以 Concurrent 开头的集合类：<br />\n以 Concurrent 开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以 Concurrent 开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。</li>\n<li>以 CopyOnWrite 开头的集合类：<br />\n以 CopyOnWrite 开头的集合类采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。</li>\n</ul>\n<h3 id=\"hashmap\"><a class=\"anchor\" href=\"#hashmap\">#</a> HashMap</h3>\n<h4 id=\"hashmap-为什么在获取-hash-值时要进行位运算\"><a class=\"anchor\" href=\"#hashmap-为什么在获取-hash-值时要进行位运算\">#</a> HashMap 为什么在获取 hash 值时要进行位运算</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol>\n<li>如果使用直接使用 hashCode 对数组大小取余，那么相当于参与运算的只有 hashCode 的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode 取值出的高位也参与运算，进一步降低 hash 碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动。</li>\n<li>而这么来看 hashCode 被散列 （异或） 的是低 16 位，而 HashMap 数组长度一般不会超过 2 的 16 次幂，那么高 16 位在大多数情况是用不到的，所以只需要拿 key 的 HashCode 和它的高 16 位做异或即可利用高位的 hash 值，降低哈希碰撞概率也使数据分布更加均匀。</li>\n</ol>\n<p><strong>为什么用异或</strong><br />\n保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash () 返回值就会改变。尽可能的减少碰撞。</p>\n<h4 id=\"jdk7-和-jdk8-中-hashmap-的区别\"><a class=\"anchor\" href=\"#jdk7-和-jdk8-中-hashmap-的区别\">#</a> JDK7 和 JDK8 中 HashMap 的区别</h4>\n<p>JDK7 中的 HashMap ，是基于数组 + 链表来实现的，它的底层维护一个 Entry 数组。它会根据计算的 hashCode 将对应的 KV 键值对存储到该数组中，一旦发生 hashCode 冲突，那么就会将该 KV 键值对放到对应的已有元素的后面， 此时便形成了一个链表式的存储结构。JDK7 中 HashMap 的实现方案有一个明显的缺点，即当 Hash 冲突严重时，在桶上形成的链表会变得越来越长，这样在查询时的效率就会越来越低，其时间复杂度为 O (N) 。</p>\n<p>JDK8 中的 HashMap ，是基于数组 + 链表 + 红黑树来实现的，它的底层维护一个 Node 数组。当链表的存储的数据个数大于等于 8 的时候，不再采用链表存储，而采用了红黑树存储结构。这么做主要是在查询的时间复杂度上进行优化，链表为 O (N) ，而红黑树一直是 O (logN) ，可以大大的提高查找性能。</p>\n<h4 id=\"hashmap-扩容\"><a class=\"anchor\" href=\"#hashmap-扩容\">#</a> HashMap 扩容</h4>\n<p><strong>JDK1.7 扩容</strong><br />\n JDK1.7 发生扩容的条件必须同时满足两点：</p>\n<ul>\n<li>当前存储的数量大于等于阈值</li>\n<li>发生 hash 碰撞</li>\n</ul>\n<p><strong>特点</strong>：先扩容，再添加（扩容使用的头插法）<br />\n<strong>缺点</strong>：头插法会使链表发生反转，多线程环境下可能会死循环<br />\n<strong>扩容结果</strong>：table 容量变为 2 倍，所有的元素下标需要重新计算，newIndex = hash （扰动后） &amp; （newLength - 1）</p>\n<p><strong>JDK1.8 扩容</strong><br />\n JDK1.8 发生扩容的条件需满足其中一项：</p>\n<ul>\n<li>当前存储的数量大于等于阈值</li>\n<li>当某个链表长度 &gt;=8，但是数组存储的结点数 size () &lt; 64 时</li>\n</ul>\n<p><strong>特点</strong>：先插后判断是否需要扩容（扩容时是尾插法）<br />\n<strong>缺点</strong>：多线程下，1.8 会有数据覆盖<br />\n table 容量变为 2 倍，但是不需要像之前一样计算下标，只需要将 hash 值和旧数组长度相与即可确定位置。</p>\n<ul>\n<li>如果 Node 桶的数据结构是链表会生成 low 和 high 两条链表，是红黑树则生成 low 和 high 两颗红黑树</li>\n<li>依靠 (hash &amp; oldCap) == 0 判断 Node 中的每个结点归属于 low 还是 high。</li>\n<li>把 low 插入到 新数组中 当前数组下标的位置，把 high 链表插入到 新数组中 [当前数组下标 + 旧数组长度] 的位置</li>\n<li>如果生成的 low，high 树中元素个数小于等于 6 退化成链表再插入到新数组的相应下标的位置</li>\n</ul>\n<h4 id=\"链表升级成红黑树的条件\"><a class=\"anchor\" href=\"#链表升级成红黑树的条件\">#</a> 链表升级成红黑树的条件</h4>\n<p>链表长度大于 8 时才会考虑升级成红黑树，是有一个条件是 HashMap 的 Node 数组长度大于等于 64（不满足则会进行一次扩容替代升级）。</p>\n<h4 id=\"红黑树退化成链表的条件\"><a class=\"anchor\" href=\"#红黑树退化成链表的条件\">#</a> 红黑树退化成链表的条件</h4>\n<ul>\n<li>扩容 resize ( ) 时，红黑树拆分成的 树的结点数小于等于临界值 6 个，则退化成链表。</li>\n<li>删除元素 remove () 时，在 removeTreeNode () 方法会检查红黑树是否满足退化条件，与结点数无关。如果红黑树根 root 为空，或者 root 的左子树 / 右子树为空，或者 根的左子树的左子树为空，都会发生红黑树退化成链表。<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> root<span class=\"token punctuation\">.</span>right <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token punctuation\">(</span>rl <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> rl<span class=\"token punctuation\">.</span>left <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    tab<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span><span class=\"token function\">untreeify</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// too small</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"concurrenthashmap\"><a class=\"anchor\" href=\"#concurrenthashmap\">#</a> ConcurrentHashMap</h3>\n<h4 id=\"jdk-17-中的实现\"><a class=\"anchor\" href=\"#jdk-17-中的实现\">#</a> JDK 1.7 中的实现：</h4>\n<p>在 jdk 1.7 中，ConcurrentHashMap 是由 Segment 数据结构和 HashEntry 数组结构构成，采取分段锁来保证安全性。Segment 是 ReentrantLock 重入锁，在 ConcurrentHashMap 中扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，Segment 的结构和 HashMap 类似，是一个数组和链表结构。<br />\n<img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645689003626/A064CF0DD49D1B3694548913C28728DB\" alt=\"ConcurrentHashMap-jdk1.7\" /><br />\nJDK1.7 中的并发方式只是相当于在一个 HashMap 中包含多个 HashMap ，在对不同 HashMap 的访问上能够提供并发，并发度取决于 Segment 数组的长度。</p>\n<h4 id=\"jdk-18-中的实现\"><a class=\"anchor\" href=\"#jdk-18-中的实现\">#</a> JDK 1.8 中的实现：</h4>\n<p>JDK1.8 的实现已经摒弃了 Segment 的概念，而是直接用 Node 数组 + 链表 + 红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作，整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。<br />\n<img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645689024609/9C8ABF1CD3475339A49DE3B9E1696FE7\" alt=\"ConcurrentHashMap-jdk1.8\" /></p>\n<h3 id=\"linkedhashmap\"><a class=\"anchor\" href=\"#linkedhashmap\">#</a> LinkedHashMap</h3>\n<ul>\n<li>LinkedHashMap 使用双向链表来维护 key-value 对的顺序（其实只需要考虑 key 的顺序），该链表负责维护 Map 的迭代顺序，迭代顺序与 key-value 对的插入顺序保持一致。在实现上，LinkedHashMap 很多方法直接继承自 HashMap，仅为维护双向链表重写了部分方法。</li>\n<li>LinkedHashMap 可以避免对 HashMap 、Hashtable 里的 key-value 对进行排序（只要插入 key-value 对时保持顺序即可），同时又可避免使用 TreeMap 所增加的成本。</li>\n<li>LinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能。但因为它以链表来维护内部顺序，所以在迭代访问 Map 里的全部元素时将有较好的性能。</li>\n</ul>\n<h3 id=\"copyonwritearraylist\"><a class=\"anchor\" href=\"#copyonwritearraylist\">#</a> CopyOnWriteArrayList</h3>\n<p>CopyOnWriteArrayList 允许线程并发访问读操作，这个时候是没有加锁限制的，性能较高。而写操作的时候，则首先将容器复制一份，然后在新的副本上执行写操作，这个时候写操作是上锁的。结束之后再将原容器的引用指向新容器。注意，在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">E</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements <span class=\"token operator\">=</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newElements <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            newElements<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newElements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">E</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements <span class=\"token operator\">=</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token class-name\">E</span> oldValue <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token keyword\">int</span> numMoved <span class=\"token operator\">=</span> len <span class=\"token operator\">-</span> index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numMoved <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>                <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newElements <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span>len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> newElements<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> newElements<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                                 numMoved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newElements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"blockingqueue\"><a class=\"anchor\" href=\"#blockingqueue\">#</a> BlockingQueue</h3>\n<table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ArrayBlockingQueue</td>\n<td>基于数组的阻塞队列，使用数组存储数据，并需要指定其长度，所以是一个有界队列</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>基于链表的阻塞队列，使用链表存储数据，默认是一个无界队列；也可以通过构造方法中的 capacity 设置最大元素数量，所以也可以作为有界队列</td>\n</tr>\n<tr>\n<td>SynchronousQueue</td>\n<td>一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费</td>\n</tr>\n<tr>\n<td>PriorityBlockingQueue</td>\n<td>基于优先级别的阻塞队列，底层基于数组实现，是一个无界队列 DelayQueue 延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</td>\n</tr>\n</tbody>\n</table>\n<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别：如果采用公平模式：SynchronousQueue 会采用公平锁，并配合一个 TransferQueue 来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 TransferStack 来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>\n<h2 id=\"thread\"><a class=\"anchor\" href=\"#thread\">#</a> Thread</h2>\n<h3 id=\"进程与线程的区别\"><a class=\"anchor\" href=\"#进程与线程的区别\">#</a> 进程与线程的区别</h3>\n<p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。<br />\n<strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br />\n<strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。<br />\n<strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。<br />\n<strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。<br />\n<strong>执行过程</strong>：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。</p>\n<h3 id=\"创建线程的方式\"><a class=\"anchor\" href=\"#创建线程的方式\">#</a> 创建线程的方式</h3>\n<p>创建线程有三种方式，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口。</p>\n<ul>\n<li>通过继承 Thread 类来创建并启动线程的步骤如下：\n<ul>\n<li>定义 Thread 类的子类，并重写该类的 run () 方法，该 run () 方法将作为线程执行体。</li>\n<li>创建 Thread 子类的实例，即创建了线程对象。</li>\n<li>调用线程对象的 start () 方法来启动该线程。</li>\n</ul>\n</li>\n<li>通过实现 Runnable 接口来创建并启动线程的步骤如下：\n<ul>\n<li>定义 Runnable 接口的实现类，并实现该接口的 run () 方法，该 run () 方法将作为线程执行体。</li>\n<li>创建 Runnable 实现类的实例，并将其作为 Thread 的 target 来创建 Threa d 对象，Thread 对象为线程对象。</li>\n<li>调用线程对象的 start () 方法来启动该线程。</li>\n</ul>\n</li>\n<li>通过实现 Callable 接口来创建并启动线程的步骤如下：\n<ul>\n<li>创建 Callable 接口的实现类，并实现 call () 方法，该 call () 方法将作为线程执行体，且该 call () 方法有返回值。然后再创建 Callable 实现类的实例。</li>\n<li>使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call () 方法的返回值。</li>\n<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>\n<li>调用 FutureTask 对象的 get () 方法来获得子线程执行结束后的返回值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"run-start\"><a class=\"anchor\" href=\"#run-start\">#</a> run() &amp; start()</h3>\n<p>run () 方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而 start () 方法用来启动线程。<br />\nstart () 方法用于启动线程，run () 方法用于执行线程的运行时代码。但如果直接调用线程对象的 run () 方法，则 run () 方法立即就会被执行，而且在 run () 方法返回之前其他线程无法并发执行。run () 可以重复调用，而 start () 只能调用一次。</p>\n<h3 id=\"thread-是否能重新启动\"><a class=\"anchor\" href=\"#thread-是否能重新启动\">#</a> Thread 是否能重新启动</h3>\n<p>只能对处于新建状态的线程调用 start () 方法，否则将引发 IllegalThreadStateException 异常。<br />\n如果想重用一个过程，可以把线程逻辑定义在 Runnable 对象里面，通过新建 Thread 对象达到重新启动逻辑的效果。</p>\n<h3 id=\"thread-的五种状态\"><a class=\"anchor\" href=\"#thread-的五种状态\">#</a> Thread 的五种状态</h3>\n<p>在线程的生命周期中，它要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）5 种状态。<br />\n<img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645689998870/B6700F052B8C52C28D140E41896513FE\" alt=\"线程 5 种状态的转换关系\" /></p>\n<h3 id=\"产生死锁的四个必要条件\"><a class=\"anchor\" href=\"#产生死锁的四个必要条件\">#</a> 产生死锁的四个必要条件：</h3>\n<ul>\n<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li>\n<li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li><strong>不剥夺条件</strong>：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>\n<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"sleep-和-wait-有什么区别\"><a class=\"anchor\" href=\"#sleep-和-wait-有什么区别\">#</a> sleep () 和 wait () 有什么区别</h3>\n<ul>\n<li>类的不同：sleep () 来自 Thread，wait () 来自 Object。</li>\n<li>释放锁：sleep () 不释放锁；wait () 释放锁。</li>\n<li>用法不同：sleep () 时间到会自动恢复；wait () 可以使用 notify () /notifyAll () 直接唤醒。</li>\n</ul>\n<h3 id=\"锁升级\"><a class=\"anchor\" href=\"#锁升级\">#</a> 锁升级</h3>\n<p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n<h2 id=\"threadpool\"><a class=\"anchor\" href=\"#threadpool\">#</a> ThreadPool</h2>\n<h3 id=\"线程池的参数\"><a class=\"anchor\" href=\"#线程池的参数\">#</a> 线程池的参数</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                            <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                            <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>                            <span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                            <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                            <span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                            <span class=\"token class-name\">RejectedExecutionHandler</span> handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>corePoolSize <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        maximumPoolSize <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        maximumPoolSize <span class=\"token operator\">&lt;</span> corePoolSize <span class=\"token operator\">||</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        keepAliveTime <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workQueue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> threadFactory <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> handler <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>corePoolSize <span class=\"token operator\">=</span> corePoolSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>maximumPoolSize <span class=\"token operator\">=</span> maximumPoolSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>workQueue <span class=\"token operator\">=</span> workQueue<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>keepAliveTime <span class=\"token operator\">=</span> unit<span class=\"token punctuation\">.</span><span class=\"token function\">toNanos</span><span class=\"token punctuation\">(</span>keepAliveTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threadFactory <span class=\"token operator\">=</span> threadFactory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handler <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li><strong>corePoolSize</strong>（核心工作线程数）：当向线程池提交一个任务时，若线程池已创建的线程数小于 corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于 corePoolSize 时。</li>\n<li><strong>maximumPoolSize</strong>（最大线程数）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于 maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</li>\n<li><strong>keepAliveTime</strong>（多余线程存活时间）：当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li>\n<li><strong>workQueue</strong>（队列）：用于传输和保存等待执行任务的阻塞队列。</li>\n<li><strong>threadFactory</strong>（线程创建工厂）：用于创建新线程。threadFactory 创建的线程也是采用 new Thread () 方式，threadFactory 创建的线程名都具有统一的风格：pool-m-thread-n（m 为线程池的编号，n 为线程池内的线程编号）。</li>\n<li><strong>handler</strong>（拒绝策略）：当线程池和队列都满了，再加入线程会执行此策略</li>\n</ul>\n<h3 id=\"默认线程池\"><a class=\"anchor\" href=\"#默认线程池\">#</a> 默认线程池</h3>\n<table>\n<thead>\n<tr>\n<th>线程池名称</th>\n<th>使用阻塞队列</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>newFixedThreadPool</td>\n<td>LinkedBlockingQueue()</td>\n<td>1、核心线程数和最大线程数相同。2、由于 keepAliveTime 设置为 0 ，当线程创建后会一直存在。3、由于用的是无界队列所以可能会导致 OOM。</td>\n</tr>\n<tr>\n<td>newSingleThreadExecutor</td>\n<td>LinkedBlockingQueue()</td>\n<td>1、核心线程数和最大线程数都为 1 ，单线程。2、无界队列可能导致 OOM 。</td>\n</tr>\n<tr>\n<td>newCachedThreadPool</td>\n<td>SynchronousQueue()</td>\n<td>1、核心线程数为 0 ，最大线程数为 Integer.MAX_VALUE 。2、当没任务时线程存活时间为 60 秒。3、使用的是 0 大小的队列，所以不存储任务，只做任务转发。4、极端情况下会创建过多的线程，耗尽 CPU 和内存资源。</td>\n</tr>\n<tr>\n<td>newScheduledThreadPool</td>\n<td>DelayedWorkQueue()</td>\n<td>1、执行周期任务。2、无界队列，可能会导致 OOM 。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"线程池工作原理\"><a class=\"anchor\" href=\"#线程池工作原理\">#</a> 线程池工作原理</h3>\n<p><img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690520076/70D6B0404AB5E9C7AF6699C94B4766BF\" alt=\"线程池工作原理\" /></p>\n<h3 id=\"线程池的拒绝策略\"><a class=\"anchor\" href=\"#线程池的拒绝策略\">#</a> 线程池的拒绝策略</h3>\n<p>当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p>\n<ul>\n<li><strong>AbortPolicy</strong>：丢弃任务并抛出 RejectedExecutionException 异常。</li>\n<li><strong>DiscardPolicy</strong>：也是丢弃任务，但是不抛出异常。</li>\n<li><strong>DiscardOldestPolicy</strong>：丢弃队列最前面的任务，然后重新尝试执行任务（重复该过程）。</li>\n<li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务。</li>\n</ul>\n",
            "tags": [
                "面试指北",
                "Java",
                "八股文",
                "Java"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/10/24/2023-10-interview-network/",
            "url": "https://haust-kevin.github.io/2023/10/24/2023-10-interview-network/",
            "title": "面试指北：计算机网络",
            "date_published": "2023-10-24T10:13:56.000Z",
            "content_html": "<h2 id=\"osi-七层网络模型\"><a class=\"anchor\" href=\"#osi-七层网络模型\">#</a> OSI 七层网络模型</h2>\n<p>OSI 的七层协议主要包括：物理层（physical layer）、数据链路层（data link layer）、网络层（network layer）、运输层（transport layer）、会话层（session layer）、表示层（presentation layer）、应用层（application layer）。</p>\n<table>\n<thead>\n<tr>\n<th>OSI 七层网络模型</th>\n<th>功能</th>\n<th>常用网络协议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n<td>应用层是网络体系中最高的一层，也是唯一面向用户的一层，也可视为为用户提供常用的应用程序，每个网络应用都对应着不同的协议</td>\n<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>主要负责数据格式的转换，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，同时也对应用层的协议进行翻译</td>\n<td>JPEG、MPEG、ASII</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信</td>\n<td>SMTP, DNS</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>是整个网络关键的部分，是实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题。是向下通信服务最高层，向上用户功能最底层。即向网络层提供服务，向会话层提供独立于网络层的传送服务和可靠的透明数据传输</td>\n<td>TCP, UDP</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>将传输层传下来的报文段封装成分组，选择合适的路由，使得传输层传下来的分组能够交付到目的主机</td>\n<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>物理地址（MAC 地址），网络设备的唯一身份标识。建立逻辑连接、进行硬件地址寻址，相邻的两个设备间的互相通信</td>\n<td>PPP、FR、HDLC、VLAN、MAC（网桥、交换机）</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>七层模型中的最底层，主要是物理介质传输媒介（网线或者是无线），在不同设备中传输比特，将 0/1 信号与电信号或者光信号互相转化</td>\n<td>IEEE 802.1A, IEEE 802.2 到 IEEE 802 （中继器、集线器）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三次握手-四次挥手\"><a class=\"anchor\" href=\"#三次握手-四次挥手\">#</a> 三次握手 &amp; 四次挥手</h2>\n<h3 id=\"三次握手\"><a class=\"anchor\" href=\"#三次握手\">#</a> 三次握手</h3>\n<h4 id=\"三次握手示意图\"><a class=\"anchor\" href=\"#三次握手示意图\">#</a> 三次握手示意图</h4>\n<p><img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697608907/3A588F923BE7D29034DABEB3AB473BCE\" alt=\"三次握手\" /></p>\n<ul>\n<li>客户端在需要时，向服务器<strong>发起请求连接报文</strong>，发出后状态从 CLOSED 转换为 SYN-SEND  同步 - 已发送状态。</li>\n<li>服务器一直处于 LISTEN 状态，接收到请求后，<strong>对客户端的请求进行回应</strong>，转换为 SYN-RCVD，同步 - 已收到状态。</li>\n<li>客户端收到服务器的回应后，状态转换为 ESTABLISHED，并且<strong>再次向服务器发送确认</strong>。</li>\n<li>服务器收到客户端的确认之后，服务器也转换为 ESTABLISHED 状态，完成了连接。</li>\n</ul>\n<h4 id=\"三次握手过程\"><a class=\"anchor\" href=\"#三次握手过程\">#</a> 三次握手过程</h4>\n<ol>\n<li>客户端发送一个 SYN0 给服务器（选择初始序列号，不携带任何数据）</li>\n<li>服务器收到 SYN0，回复 SYN1 和 ACK（服务器分配缓存，选择自己初始序列号）</li>\n<li>客户端收到 SYN1、ACK，回复 ACK（可以包含数据）</li>\n</ol>\n<h4 id=\"为什么要三次握手\"><a class=\"anchor\" href=\"#为什么要三次握手\">#</a> 为什么要三次握手</h4>\n<p>如果不是三次握手，只有两次<br />\n如果客户端发出请求连接时，报文延时了，于是客户端重新发送了一次连接请求消息<br />\n后来收到了确认，建立了连接，然后完成了数据传输，关闭了连接<br />\n此时，服务器收到了那个迟到的请求消息，此时这个请求不应该建立双向的连接。<br />\n但是如果只有两次握手，服务器收到请求就响应建立了连接了<br />\n但是如果是三次，客户端不会再次确认，服务器也就随后知道了这消息有问题，不会建立连接</p>\n<h3 id=\"四次挥手\"><a class=\"anchor\" href=\"#四次挥手\">#</a> 四次挥手</h3>\n<h4 id=\"四次挥手示意图\"><a class=\"anchor\" href=\"#四次挥手示意图\">#</a> 四次挥手示意图</h4>\n<p><img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697582360/95BEBBEC5A8D1A75D8FE435BD5FDBA12\" alt=\"四次挥手\" /></p>\n<ul>\n<li>\n<p>客户端进程<strong>发出连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</p>\n</li>\n<li>\n<p>服务器收到连接释放报文，<strong>发出确认报文</strong>，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p>\n</li>\n<li>\n<p>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>\n</li>\n<li>\n<p>服务器将最后的数据发送完毕后，就向客户端<strong>发送连接释放报文</strong>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p>\n</li>\n<li>\n<p>客户端收到服务器的连接释放报文后，<strong>必须发出确认</strong>，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p>\n</li>\n<li>\n<p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p>\n</li>\n</ul>\n<h4 id=\"四次挥手过程\"><a class=\"anchor\" href=\"#四次挥手过程\">#</a> 四次挥手过程：</h4>\n<ol>\n<li>客户端向服务器发送 FIN 控制报文段（首部中的 FIN 比特被置位）；</li>\n<li>服务端收到 FIN，回复 ACK。服务器进入关闭等待状态，发送 FIN;</li>\n<li>客户端收到 FIN，给服务器回复 ACK，客户端进入等待状态（进入 “等待”，以确保服务器收到 ACK 真正关闭连接）;</li>\n<li>服务端收到 ACK，链接关闭。</li>\n</ol>\n<h4 id=\"四次挥手原因\"><a class=\"anchor\" href=\"#四次挥手原因\">#</a> 四次挥手原因：</h4>\n<p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当客户端发出 FIN 报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务端的数据；当服务端返回 ACK 报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；当服务端也发送了 FIN 报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。</p>\n<h2 id=\"粘包\"><a class=\"anchor\" href=\"#粘包\">#</a> 粘包</h2>\n<p>TCP 粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>\n<h3 id=\"原因\"><a class=\"anchor\" href=\"#原因\">#</a> 原因</h3>\n<ol>\n<li>发送方原因<br />\n TCP 默认使用 Nagle 算法（主要作用：减少网络中报文段的数量），而 Nagle 算法主要做两件事：</li>\n</ol>\n<ul>\n<li>只有上一个分组得到确认，才会发送下一个分组</li>\n<li>收集多个小分组，在一个确认到来时一起发送</li>\n</ul>\n<ol start=\"2\">\n<li>接收方原因<br />\n TCP 接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP 将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果 TCP 接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>\n</ol>\n<h3 id=\"处理方式\"><a class=\"anchor\" href=\"#处理方式\">#</a> 处理方式</h3>\n<ul>\n<li>发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度；</li>\n<li>发送端在每个包的末尾使用固定的分隔符，例如 <code>\\r\\n</code> 。如果发生拆包需等待多个包发送过来之后再找到其中的、r\\n 进行合并；例如，FTP 协议；</li>\n<li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li>\n</ul>\n<h3 id=\"为什么-udp-没有粘包\"><a class=\"anchor\" href=\"#为什么-udp-没有粘包\">#</a> 为什么 UDP 没有粘包</h3>\n<p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于 UDP 有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在 TCP 协议中。</p>\n<h2 id=\"http-https\"><a class=\"anchor\" href=\"#http-https\">#</a> HTTP &amp; HTTPS</h2>\n<h3 id=\"http\"><a class=\"anchor\" href=\"#http\">#</a> HTTP</h3>\n<p>HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<h4 id=\"http-请求方法\"><a class=\"anchor\" href=\"#http-请求方法\">#</a> HTTP 请求方法</h4>\n<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。<br />\nHTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>\n<table>\n<thead>\n<tr>\n<th>REQUEST METHOD</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和 / 或已有资源的修改。</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"http-状态码\"><a class=\"anchor\" href=\"#http-状态码\">#</a> HTTP 状态码</h4>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>状态码英文名称</th>\n<th>中文描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>Continue</td>\n<td>继续。客户端应继续其请求</td>\n</tr>\n<tr>\n<td>101</td>\n<td>Switching Protocols</td>\n<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</td>\n</tr>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>请求成功。一般用于 GET 与 POST 请求</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>已创建。成功请求并创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>已接受。已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td>203</td>\n<td>Non-Authoritative Information</td>\n<td>非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No Content</td>\n<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>\n</tr>\n<tr>\n<td>205</td>\n<td>Reset Content</td>\n<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>\n</tr>\n<tr>\n<td>206</td>\n<td>Partial Content</td>\n<td>部分内容。服务器成功处理了部分 GET 请求</td>\n</tr>\n<tr>\n<td>300</td>\n<td>Multiple Choices</td>\n<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>\n</tr>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新</td>\n<td>的 URI 代替</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>查看其它地址。与 301 类似。使用 GET 和 POST 请求查看</td>\n</tr>\n<tr>\n<td>304</td>\n<td>Not Modified</td>\n<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>\n</tr>\n<tr>\n<td>305</td>\n<td>Use Proxy</td>\n<td>使用代理。所请求的资源必须通过代理访问</td>\n</tr>\n<tr>\n<td>306</td>\n<td>Unused</td>\n<td>已经被废弃的 HTTP 状态码</td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>临时重定向。与 302 类似。使用 GET 请求重定向</td>\n</tr>\n<tr>\n<td>400</td>\n<td>Bad Request</td>\n<td>客户端请求的语法错误，服务器无法理解</td>\n</tr>\n<tr>\n<td>401</td>\n<td>Unauthorized</td>\n<td>请求要求用户的身份认证</td>\n</tr>\n<tr>\n<td>402</td>\n<td>Payment Required</td>\n<td>保留，将来使用</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 &quot;您所请求的资源无法找到&quot;  的个性页面</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>客户端请求中的方法被禁止</td>\n</tr>\n<tr>\n<td>406</td>\n<td>Not Acceptable</td>\n<td>服务器无法根据客户端请求的内容特性完成请求</td>\n</tr>\n<tr>\n<td>407</td>\n<td>Proxy Authentication Required</td>\n<td>请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Time-out</td>\n<td>服务器等待客户端发送的请求时间过长，超时</td>\n</tr>\n<tr>\n<td>409</td>\n<td>Conflict\t服务器完成客户端的 PUT</td>\n<td>请求时可能返回此代码，服务器处理请求时发生了冲突</td>\n</tr>\n<tr>\n<td>410</td>\n<td>Gone</td>\n<td>客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</td>\n</tr>\n<tr>\n<td>411</td>\n<td>Length Required</td>\n<td>服务器无法处理客户端发送的不带 Content-Length 的请求信息</td>\n</tr>\n<tr>\n<td>412</td>\n<td>Precondition Failed</td>\n<td>客户端请求信息的先决条件错误</td>\n</tr>\n<tr>\n<td>413</td>\n<td>Request Entity Too Large</td>\n<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息</td>\n</tr>\n<tr>\n<td>414</td>\n<td>Request-URI Too Large</td>\n<td>请求的 URI 过长（URI 通常为网址），服务器无法处理</td>\n</tr>\n<tr>\n<td>415</td>\n<td>Unsupported Media Type</td>\n<td>服务器无法处理请求附带的媒体格式</td>\n</tr>\n<tr>\n<td>416</td>\n<td>Requested range not satisfiable</td>\n<td>客户端请求的范围无效</td>\n</tr>\n<tr>\n<td>417</td>\n<td>Expectation Failed</td>\n<td>服务器无法满足 Expect 的请求头信息</td>\n</tr>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器内部错误，无法完成请求</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>服务器不支持请求的功能，无法完成请求</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</td>\n</tr>\n<tr>\n<td>504</td>\n<td>Gateway Time-out</td>\n<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>\n</tr>\n<tr>\n<td>505</td>\n<td>HTTP Version not supported</td>\n<td>服务器不支持请求的 HTTP 协议的版本，无法完成处理</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"restfull\"><a class=\"anchor\" href=\"#restfull\">#</a> RESTFULL</h4>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>GET /collection：从服务器查询资源的列表（数组）</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>GET /collection/resource：从服务器查询单个资源</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>POST /collection：在服务器创建新的资源</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>PUT /collection/resource：更新服务器资源</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>DELETE /collection/resource：从服务器删除资源</pre></td></tr></table></figure><p>四个方法除 POST 之外都需要保持幂等性。</p>\n<h3 id=\"https\"><a class=\"anchor\" href=\"#https\">#</a> HTTPS</h3>\n<p><strong>HTTPS</strong>（Hyper Text Transfer Protocol over SecureSocket Layer）是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>\n<p><img data-src=\"https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697886891/B7268EF66524898CEF0E068EA5F1BA26\" alt=\"https 示意图\" /><br />\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图上图所示：</p>\n<ol>\n<li>客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。</li>\n<li>Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li>\n<li>客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。</li>\n<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>\n<li>Web 服务器利用自己的私钥解密出会话密钥。</li>\n<li>Web 服务器利用会话密钥加密与客户端之间的通信。</li>\n</ol>\n<h2 id=\"其它问题\"><a class=\"anchor\" href=\"#其它问题\">#</a> 其它问题</h2>\n<ol>\n<li>\n<p>介绍一下 HTTP 协议中的长连接和短连接。<br />\nHTTP 协议的底层使用 TCP 协议，所以 HTTP 协议的长连接和短连接在本质上是 TCP 层的长连接和短连接。由于 TCP 建立连接、维护连接、释放连接都是要消耗一定的资源，浪费一定的时间。所对于服务器来说，频繁的请求释放连接会浪费大量的时间，长时间维护太多的连接的话又需要消耗资源。所以长连接和短连接并不存在优劣之分，只是适用的场合不同而已。长连接和短连接分别有如下优点和缺点：<br />\n<strong>长连接优点</strong>：可以节省较多的 TCP 连接和释放的操作，节约时间，对于频繁请求资源的用户来说，适合长连接。<br />\n<strong>长连接缺点</strong>：由于有保活功能，当遇到大量的恶意连接时，服务器的压力会越来越大。这时服务器需要采取一些策略，关闭一些长时间没有进行读写事件的的连接。<br />\n<strong>短连接优点</strong>：短连接对服务器来说管理比较简单，只要存在的连接都是有效连接，不需要额外的控制手段，而且不会长时间占用资源 。<br />\n<strong>短连接缺点</strong>：如果客户端请求频繁的话，会在 TCP 的建立和释放上浪费大量的时间。<br />\n从 HTTP/1.1 版本起，默认使用长连接用以保持连接特性。使用长连接的 HTTP 协议，会在响应消息报文段加入：Connection: keep-alive。TCP 中也有 keep alive，但是 TCP 中的 keep alive 只是探测 TCP 连接是否活着，而 HTTP 中的 keep-alive 是让一个 TCP 连接获得更久一点。</p>\n</li>\n<li>\n<p>说一说 HTTPS 的证书认证过程。</p>\n<ol>\n<li>\n<p>浏览器将自己支持的一套加密规则发送给网站。</p>\n</li>\n<li>\n<p>网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>\n</li>\n<li>\n<p>浏览器获得网站证书之后浏览器要做以下工作：</p>\n</li>\n</ol>\n<ul>\n<li>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li>\n<li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li>\n<li>使用约定好的 HASH 算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li>\n</ul>\n<ol start=\"4\">\n<li>网站接收浏览器发来的数据之后要做以下的操作：</li>\n</ol>\n<ul>\n<li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。</li>\n<li>使用密码加密一段握手消息，发送给浏览器。</li>\n</ul>\n<ol start=\"5\">\n<li>浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>\n</ol>\n</li>\n<li>\n<p>打开浏览器从输入网址到网页呈现在大家面前，背后发生了什么？<br />\nDNS 解析：将域名解析成 IP 地址<br />\n TCP 连接：TCP 三次握手<br />\n发送 HTTP 请求<br />\n服务器处理请求并返回 HTTP 报文<br />\n浏览器解析渲染页面<br />\n断开连接：TCP 四次挥手</p>\n</li>\n</ol>\n",
            "tags": [
                "面试指北",
                "计算机基础",
                "八股文",
                "计算机网络"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/10/17/2023-10-bubble-sort/",
            "url": "https://haust-kevin.github.io/2023/10/17/2023-10-bubble-sort/",
            "title": "冒泡排序、鸡尾酒排序、梳子排序",
            "date_published": "2023-10-17T01:40:45.000Z",
            "content_html": "<div class=\"note primary\">\n<p>冒泡排序及其变种</p>\n</div>\n<h1 id=\"冒泡排序\"><a class=\"anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h1>\n<h2 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h2>\n<p><strong>冒泡排序</strong>，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。每次冒泡，都会将最大的数移动到最末端，并缩小冒泡范围。</p>\n<h2 id=\"动画\"><a class=\"anchor\" href=\"#动画\">#</a> 动画</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310171010738.gif\" alt=\"冒泡排序\" /></p>\n<h2 id=\"代码示例\"><a class=\"anchor\" href=\"#代码示例\">#</a> 代码示例</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> vec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> vec<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">bool</span> swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> vec<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> vec<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vec<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>swapFlag<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"鸡尾酒排序\"><a class=\"anchor\" href=\"#鸡尾酒排序\">#</a> 鸡尾酒排序</h1>\n<h2 id=\"介绍-2\"><a class=\"anchor\" href=\"#介绍-2\">#</a> 介绍</h2>\n<p><strong>鸡尾酒排序</strong>，是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的性能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。鸡尾酒排序，对于乌龟（序列末端较小的数）比较多的情况，相对于原始冒泡排序有更好的性能。<br />\n以序列（2,3,4,5,1）为例，鸡尾酒排序只需要访问一次（来回两趟）序列就可以完成排序，但如果使用冒泡排序则需要四次。</p>\n<h2 id=\"动画-2\"><a class=\"anchor\" href=\"#动画-2\">#</a> 动画</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310171008464.gif\" alt=\"鸡尾酒排序\" /></p>\n<h2 id=\"代码示例-2\"><a class=\"anchor\" href=\"#代码示例-2\">#</a> 代码示例</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">cocktailSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> vec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> vec<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">bool</span> swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> vec<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vec<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> left<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> vec<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vec<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>swapFlag<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"梳子排序\"><a class=\"anchor\" href=\"#梳子排序\">#</a> 梳子排序</h1>\n<h2 id=\"介绍-3\"><a class=\"anchor\" href=\"#介绍-3\">#</a> 介绍</h2>\n<p><strong>梳子排序</strong>，改良自冒泡排序和快速排序，其要旨在于消除乌龟，亦即在数组尾部的小数值，这些数值是造成冒泡排序缓慢的主因。相对地，兔子，亦即在数组前端的大数值，不影响冒泡排序的性能。<br />\n在冒泡排序中，只比较数组中相邻的二项，即比较的二项的间距（Gap）是 1，梳排序提出此间距其实可大于 1，改自插入排序的希尔排序同样提出相同观点。梳排序中，开始时的间距设置为数组长度，并在循环中以固定比率递减，通常递减率设置为 1.3（约为原 gap 的 1/8）。在一次循环中，梳排序如同冒泡排序一样把数组从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于 1。如果间距递减至 1，梳排序假定输入数组大致排序好，并以冒泡排序作最后检查及修正。<br />\n在 gap 大于 1 时，每次将 gap 递减并执行一次冒泡过程，在 gap 变到 1 时，执行正常的冒泡排序，但是由于前面的梳理，只需要极少量的冒泡就能得到有序的数组。</p>\n<h2 id=\"动画-3\"><a class=\"anchor\" href=\"#动画-3\">#</a> 动画</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/haust-Kevin/static@master//images/202310171022862.gif\" alt=\"梳排序\" /></p>\n<h2 id=\"代码示例-3\"><a class=\"anchor\" href=\"#代码示例-3\">#</a> 代码示例</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">combSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> vec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> vec<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">bool</span> swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>gap <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> swapFlag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>gap <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            gap <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span>gap <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> gap <span class=\"token operator\">+</span> i <span class=\"token operator\">&lt;</span> vec<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> vec<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>vec<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vec<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                swapFlag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"递减率\"><a class=\"anchor\" href=\"#递减率\">#</a> 递减率</h2>\n<p>递减率的设置影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为 1.3 的。如果此比率太小，则导致一循环中有过多的比较，如果比率太大，则未能有效消除数组中的乌龟。<br />\n亦有人提议用！<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpbWVkaWEub3JnL2FwaS9yZXN0X3YxL21lZGlhL21hdGgvcmVuZGVyL3N2Zy81YTY5MGFmODc0NGRlZGZjOGU1YzdjNTAzMWM2YjRjYWMxYWQ2OGEz\"></span> 作递减率，同时增加换算表协助于每一循环开始时计算新间距。<br />\n因为编程语言中乘法比除法快，故会取递减率倒数与间距相乘，<img data-src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/cf95dfe8165efadd4f406a92b6874f423f9a84c4\" alt=\"\" /></p>\n<h2 id=\"其它优化\"><a class=\"anchor\" href=\"#其它优化\">#</a> 其它优化</h2>\n<p>设置递减率为 1.3 时，最后只会有三种不同的间距组合：(9, 6, 4, 3, 2, 1)、(10, 7, 5, 3, 2, 1)、或 (11, 8, 6, 4, 3, 2, 1)。实验证明，如果间距变成 9 或 10 时一律改作 11，则对效率有明显改善，原因是如果间距曾经是 9 或 10，则到间距变成 1 时，数值通常不是递增序列，故此要进行几次冒泡排序循环修正。加入此指定间距的变异形式称为<strong>梳排序 - 11</strong></p>\n<h2 id=\"bilibili-视频分享\"><a class=\"anchor\" href=\"#bilibili-视频分享\">#</a> bilibili 视频分享</h2>\n<p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">\n<iframe src=\"//player.bilibili.com/player.html?aid=990702293&bvid=BV1Fx4y1M7UZ&cid=974799135&p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe>\n</div>\n</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>冒泡排序、鸡尾酒排序、梳排序都是优美的算法，后两种属于第一种的优化，但是冒泡排序只适合处理序列大致有序的情况，对于绝大多数的一般序列远不如归并排序、快速排序等算法。也不会有任何语言将冒泡排序作为默认的排序算法，他们大都选择快速排序 + 插入排序的组合算法。</p>\n",
            "tags": [
                "数据结构与算法",
                "算法基础",
                "排序算法"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/09/04/2023-09-sgs-wallpaper/",
            "url": "https://haust-kevin.github.io/2023/09/04/2023-09-sgs-wallpaper/",
            "title": "三国杀官方原画",
            "date_published": "2023-09-04T10:13:39.000Z",
            "content_html": "<div class=\"note primary\">\n<p>官方公开的原画。</p>\n</div>\n<p>最近在找 DIY 三国杀武将制图的资料，发现三国杀官方有公开的部分原画，我通过 Python 提取出来给大家分享一下。</p>\n<h1 id=\"二十四节气\"><a class=\"anchor\" href=\"#二十四节气\">#</a> 二十四节气</h1>\n<h2 id=\"处暑\"><a class=\"anchor\" href=\"#处暑\">#</a> 处暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/K30Wdy1ApCF4lv5QEaU4dW2mUUlrMGAb6GAfui4n.jpeg\" alt=\"处暑\" /></p>\n<h2 id=\"立秋\"><a class=\"anchor\" href=\"#立秋\">#</a> 立秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/YsCiKuMeW3YFL0qIsvXd83RK2e7Q8sfwyVaySOpM.jpeg\" alt=\"立秋\" /></p>\n<h2 id=\"大暑\"><a class=\"anchor\" href=\"#大暑\">#</a> 大暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/6l6qW7xf9JOX1Epbt2Jl2echk8WBBN5Km4O1DXu9.jpeg\" alt=\"大暑\" /></p>\n<h2 id=\"小暑\"><a class=\"anchor\" href=\"#小暑\">#</a> 小暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/OIHSRVQq9qMwqHfapVW9fYCkfAn4EdS0d3Sc1uHt.jpeg\" alt=\"小暑\" /></p>\n<h2 id=\"夏至\"><a class=\"anchor\" href=\"#夏至\">#</a> 夏至</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/QT4SbPC8ahaR4K4YQe5IJl20fVyF5hEgA18YsbF1.jpeg\" alt=\"夏至\" /></p>\n<h2 id=\"芒种\"><a class=\"anchor\" href=\"#芒种\">#</a> 芒种</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/yfzhEPpe7XR9qdi7kAEPG9PYGkayHY0ZO50sOPGd.jpeg\" alt=\"芒种\" /></p>\n<h2 id=\"小满\"><a class=\"anchor\" href=\"#小满\">#</a> 小满</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/JUtT7BNyLNBXuYVF5zMRoMjbOnSS7TpVID2mG4XM.jpeg\" alt=\"小满\" /></p>\n<h2 id=\"立夏\"><a class=\"anchor\" href=\"#立夏\">#</a> 立夏</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/NxSSX3l6fXHgmSoBJ3rjLf5fVrqPZX97UK7sR5tO.jpeg\" alt=\"立夏\" /></p>\n<h2 id=\"谷雨\"><a class=\"anchor\" href=\"#谷雨\">#</a> 谷雨</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/AAeaiENBOa3DIdXIUr9YMD0Jb69IPWA0qm9yQawi.jpeg\" alt=\"谷雨\" /></p>\n<h2 id=\"清明\"><a class=\"anchor\" href=\"#清明\">#</a> 清明</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/EXWshTCXLobNtegeCbCUrs1qB1Do1x120s1K8lPv.jpeg\" alt=\"清明\" /></p>\n<h2 id=\"春分\"><a class=\"anchor\" href=\"#春分\">#</a> 春分</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/URX7WOFGoKE2eTkrX7XBGx43qemQiixqWsxw8bKy.jpeg\" alt=\"春分\" /></p>\n<h2 id=\"惊蛰\"><a class=\"anchor\" href=\"#惊蛰\">#</a> 惊蛰</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/C6oeBaGMxPXnp6hCqoUhQfNHw9XCesCqJj4B18wU.jpeg\" alt=\"惊蛰\" /></p>\n<h2 id=\"雨水\"><a class=\"anchor\" href=\"#雨水\">#</a> 雨水</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/SxfAs41sLug4Hjn62jS4HpymRSmwClo2KwyoqATJ.jpeg\" alt=\"雨水\" /></p>\n<h2 id=\"立春\"><a class=\"anchor\" href=\"#立春\">#</a> 立春</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/CXVpDNndOnquHeltGSuYEVk4qxZuDlzpJxzp31cZ.jpeg\" alt=\"立春\" /></p>\n<h2 id=\"大寒\"><a class=\"anchor\" href=\"#大寒\">#</a> 大寒</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/XZkwkQkIALrWgyGOG2sSh1X9qlgiNoXan64qepCA.jpeg\" alt=\"大寒\" /></p>\n<h2 id=\"小寒\"><a class=\"anchor\" href=\"#小寒\">#</a> 小寒</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/uk8pjnheZ3TOZJlCs48s6656KRVTyroszkN7izSu.jpeg\" alt=\"小寒\" /></p>\n<h2 id=\"冬至\"><a class=\"anchor\" href=\"#冬至\">#</a> 冬至</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/dDRSORSJvwyK7JslxXhMZrBJHB1YFto5T5qfvOAU.jpeg\" alt=\"冬至\" /></p>\n<h2 id=\"大雪\"><a class=\"anchor\" href=\"#大雪\">#</a> 大雪</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/JX3Dp9ca3cDkeNUak6X7W5AO66Ywc2XTfSsmjbx3.jpeg\" alt=\"大雪\" /></p>\n<h2 id=\"霜降\"><a class=\"anchor\" href=\"#霜降\">#</a> 霜降</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/nDtqZ7PDhMGlkEu8t8fb8kEDyWU7YioE8D6Mi5cY.jpeg\" alt=\"霜降\" /></p>\n<h2 id=\"小雪\"><a class=\"anchor\" href=\"#小雪\">#</a> 小雪</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/w3Nz1MLoiu3E84DC81vQpvnoYi2M5cKJV59x7U3z.jpeg\" alt=\"小雪\" /></p>\n<h2 id=\"小暑-2\"><a class=\"anchor\" href=\"#小暑-2\">#</a> 小暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/Rt2IG88FWYskcTQR36EJDn8Io8cjQYqMftdiu9ip.jpeg\" alt=\"小暑\" /></p>\n<h2 id=\"秋分\"><a class=\"anchor\" href=\"#秋分\">#</a> 秋分</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/0rABBF488yydCkoYjBoMSYnFQv8CjGkRnZRaUexK.jpeg\" alt=\"秋分\" /></p>\n<h2 id=\"立秋-2\"><a class=\"anchor\" href=\"#立秋-2\">#</a> 立秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/QvirFR4gaNnSPTWegOwvPwaPZTAFPvIMRpXJGzGI.jpeg\" alt=\"立秋\" /></p>\n<h2 id=\"立冬\"><a class=\"anchor\" href=\"#立冬\">#</a> 立冬</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/WEQ6Tm7I8PftgPSkXBQLugsfyGWorwlsEUMVcnN5.jpeg\" alt=\"立冬\" /></p>\n<h2 id=\"寒露\"><a class=\"anchor\" href=\"#寒露\">#</a> 寒露</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/0ojelnJjtdrOvR0aLwIOu2ZMIFvsD1VFrf0G6NKm.jpeg\" alt=\"寒露\" /></p>\n<h2 id=\"大暑-2\"><a class=\"anchor\" href=\"#大暑-2\">#</a> 大暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/G9HhmaUkiKmLWoshxADXkFfZYqtN1TF1Lv339e4A.jpeg\" alt=\"大暑\" /></p>\n<h2 id=\"处暑-2\"><a class=\"anchor\" href=\"#处暑-2\">#</a> 处暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/G88qKGvPR9JWiRrBSnE5c8bg4BHsjFRJCDU5Ucpy.jpeg\" alt=\"处暑\" /></p>\n<h2 id=\"白露\"><a class=\"anchor\" href=\"#白露\">#</a> 白露</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/p84hrkkwTTGS8stmA2YSHRY7aP4u1QXV1GoFbkcK.jpeg\" alt=\"白露\" /></p>\n<h2 id=\"立秋-3\"><a class=\"anchor\" href=\"#立秋-3\">#</a> 立秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045423c5e07ed4214486f3417dc81cb21ea23a.jpeg\" alt=\"立秋\" /></p>\n<h2 id=\"寒露-2\"><a class=\"anchor\" href=\"#寒露-2\">#</a> 寒露</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045409123cc3d787608ea2b28a9b5bc2eda06f.jpeg\" alt=\"寒露\" /></p>\n<h2 id=\"大暑-3\"><a class=\"anchor\" href=\"#大暑-3\">#</a> 大暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/2022101004535804ebef8b059965c26a9141358e20ee3f.jpeg\" alt=\"大暑\" /></p>\n<h2 id=\"小暑-3\"><a class=\"anchor\" href=\"#小暑-3\">#</a> 小暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045344804109cf6cfa4c2af24809d1224ce975.jpeg\" alt=\"小暑\" /></p>\n<h2 id=\"秋分-2\"><a class=\"anchor\" href=\"#秋分-2\">#</a> 秋分</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/202210100453310ba4b1c7cfdbbf5542f8a6f183af1cb1.jpeg\" alt=\"秋分\" /></p>\n<h2 id=\"处暑-3\"><a class=\"anchor\" href=\"#处暑-3\">#</a> 处暑</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/202210100453196a4d1a12415b91f5387009df63f8a7f5.jpeg\" alt=\"处暑\" /></p>\n<h2 id=\"白露-2\"><a class=\"anchor\" href=\"#白露-2\">#</a> 白露</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045305747ee83d80d4d567e237a1a15b431036.jpeg\" alt=\"白露\" /></p>\n<h2 id=\"雨水-2\"><a class=\"anchor\" href=\"#雨水-2\">#</a> 雨水</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045253d55e387a56f50ca73ffe34a2073347c8.jpeg\" alt=\"雨水\" /></p>\n<h2 id=\"小雪-2\"><a class=\"anchor\" href=\"#小雪-2\">#</a> 小雪</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045241b701ca8392f071c586e706fd07ad4d5e.jpeg\" alt=\"小雪\" /></p>\n<h2 id=\"小满-2\"><a class=\"anchor\" href=\"#小满-2\">#</a> 小满</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045228bdeeab34890b66188b689adf33dfd7d8.jpeg\" alt=\"小满\" /></p>\n<h2 id=\"小寒-2\"><a class=\"anchor\" href=\"#小寒-2\">#</a> 小寒</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045220fc7b0b28fa4892320840707c60b44290.jpeg\" alt=\"小寒\" /></p>\n<h2 id=\"夏至-2\"><a class=\"anchor\" href=\"#夏至-2\">#</a> 夏至</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045106dbbaa5f93b6f5445be99f2d47e0e21e4.jpeg\" alt=\"夏至\" /></p>\n<h2 id=\"霜降-2\"><a class=\"anchor\" href=\"#霜降-2\">#</a> 霜降</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045056fe2d9728f870209539c43ffa633a214e.jpeg\" alt=\"霜降\" /></p>\n<h2 id=\"芒种-2\"><a class=\"anchor\" href=\"#芒种-2\">#</a> 芒种</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010045042f993813aa3183ba51bdc12563d6bc4c5.jpeg\" alt=\"芒种\" /></p>\n<h2 id=\"立夏-2\"><a class=\"anchor\" href=\"#立夏-2\">#</a> 立夏</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/2022101004501381a72e66b146e10d5f60ada7aaea968b.jpeg\" alt=\"立夏\" /></p>\n<h2 id=\"立春-2\"><a class=\"anchor\" href=\"#立春-2\">#</a> 立春</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/202210100449567318cf603d9b32ba930a88a70d3a4444.jpeg\" alt=\"立春\" /></p>\n<h2 id=\"惊蛰-2\"><a class=\"anchor\" href=\"#惊蛰-2\">#</a> 惊蛰</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010044941f15843d99be0d1b3ba0670fa651409f8.jpeg\" alt=\"惊蛰\" /></p>\n<h2 id=\"谷雨-2\"><a class=\"anchor\" href=\"#谷雨-2\">#</a> 谷雨</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010044927974a79b4105e1db8ee467880302cb083.jpeg\" alt=\"谷雨\" /></p>\n<h2 id=\"冬至-2\"><a class=\"anchor\" href=\"#冬至-2\">#</a> 冬至</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/202210100447241c8326f952a464301e4051375673f0ff.jpeg\" alt=\"冬至\" /></p>\n<h2 id=\"大雪-2\"><a class=\"anchor\" href=\"#大雪-2\">#</a> 大雪</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010044711a26ac4777f8f886192488c0e26922f47.jpeg\" alt=\"大雪\" /></p>\n<h2 id=\"大寒-2\"><a class=\"anchor\" href=\"#大寒-2\">#</a> 大寒</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/2022101004465648203934bdd7df0e0daa221e740eb072.jpeg\" alt=\"大寒\" /></p>\n<h2 id=\"春分-2\"><a class=\"anchor\" href=\"#春分-2\">#</a> 春分</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/20221010040341f0cf9922b6ca9a51fdb88ee3e880e50d.jpeg\" alt=\"春分\" /></p>\n<h1 id=\"原画皮肤\"><a class=\"anchor\" href=\"#原画皮肤\">#</a> 原画皮肤</h1>\n<h2 id=\"钟会-潜蛟觊天-终极形态\"><a class=\"anchor\" href=\"#钟会-潜蛟觊天-终极形态\">#</a> 钟会 - 潜蛟觊天 - 终极形态</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/D7TrosDX18Emcsgh0N5VS2npeSYTUl5qlijW815K.jpeg\" alt=\"钟会-潜蛟觊天-终极形态\" /></p>\n<h2 id=\"钟会-潜蛟觊天\"><a class=\"anchor\" href=\"#钟会-潜蛟觊天\">#</a> 钟会 - 潜蛟觊天</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/CkjlwbTwtAL1VmWNs0nk2e7F6f8BpEv2Dp8a2EMU.jpeg\" alt=\"钟会-潜蛟觊天\" /></p>\n<h2 id=\"貂蝉-舞惑群心\"><a class=\"anchor\" href=\"#貂蝉-舞惑群心\">#</a> 貂蝉 - 舞惑群心</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/jFRfaD6OGALMzUHw4bxO0kN4HN3vNpeaFU2YaTTy.jpeg\" alt=\"貂蝉-舞惑群心\" /></p>\n<h2 id=\"刘协-困龙犹斗\"><a class=\"anchor\" href=\"#刘协-困龙犹斗\">#</a> 刘协 - 困龙犹斗</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/eMpeYXFvgqaI3AE96GT0wuqmMTVxS4W4Cvm329ty.jpeg\" alt=\"刘协-困龙犹斗\" /></p>\n<h2 id=\"神张辽-威震江东\"><a class=\"anchor\" href=\"#神张辽-威震江东\">#</a> 神张辽 - 威震江东</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/YcVOpo7kZQBg8RyOZ2VB8EGFFzzcwm7cqmiEk70V.jpeg\" alt=\"神张辽-威震江东\" /></p>\n<h2 id=\"神刘备-龙兴海内\"><a class=\"anchor\" href=\"#神刘备-龙兴海内\">#</a> 神刘备 - 龙兴海内</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/vx9DxmSHCTzXrfETQoKi2FZ2LVoqAvmMJxd76Kym.jpeg\" alt=\"神刘备-龙兴海内\" /></p>\n<h2 id=\"神关羽-佑子伐吴\"><a class=\"anchor\" href=\"#神关羽-佑子伐吴\">#</a> 神关羽 - 佑子伐吴</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/fOD2tOaTnm67Y7YxV7rcKf1JRqs43s7LtqZsrTMF.jpeg\" alt=\"神关羽-佑子伐吴\" /></p>\n<h2 id=\"卑弥呼-呼风唤雨\"><a class=\"anchor\" href=\"#卑弥呼-呼风唤雨\">#</a> 卑弥呼 - 呼风唤雨</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/QPvP8MP3HnzmRkIiSyZmzH1cHM9JunNmnYm0T6yQ.jpeg\" alt=\"卑弥呼-呼风唤雨\" /></p>\n<h2 id=\"钟会-欲谋自立\"><a class=\"anchor\" href=\"#钟会-欲谋自立\">#</a> 钟会 - 欲谋自立</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/pZV3fY9x7R2AIodn6D82N78EIIq31noN68WDFNld.jpeg\" alt=\"钟会-欲谋自立\" /></p>\n<h2 id=\"许攸-火烧乌巢\"><a class=\"anchor\" href=\"#许攸-火烧乌巢\">#</a> 许攸 - 火烧乌巢</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/8L2NDoxFZNbFRESjCsHt6FSCY6zhnKlI7uUOVIyE.jpeg\" alt=\"许攸-火烧乌巢\" /></p>\n<h2 id=\"步练师-鸾飞凤舞\"><a class=\"anchor\" href=\"#步练师-鸾飞凤舞\">#</a> 步练师 - 鸾飞凤舞</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/OljZVmbHXPlMJDpC25FfVznGeeajkS8KmpxRi8JM.jpeg\" alt=\"步练师-鸾飞凤舞\" /></p>\n<h2 id=\"大乔小乔-姐妹情深\"><a class=\"anchor\" href=\"#大乔小乔-姐妹情深\">#</a> 大乔小乔 - 姐妹情深</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/a8JpNERvdL5ZpFnj2Pc65zz0MadFHN0xuSsWEmys.jpeg\" alt=\"大乔小乔-姐妹情深\" /></p>\n<h2 id=\"王元姬-谆谆教导\"><a class=\"anchor\" href=\"#王元姬-谆谆教导\">#</a> 王元姬 - 谆谆教导</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/JyeWpcFXiPJn8xxbF1J7pLTgc2gpmLy8fEB6PCsY.jpeg\" alt=\"王元姬-谆谆教导\" /></p>\n<h2 id=\"周仓-青龙化力\"><a class=\"anchor\" href=\"#周仓-青龙化力\">#</a> 周仓 - 青龙化力</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/3J9gOIVWmOwNWuE2bPizDdJIWkJ16qETmpEpqh3r.jpeg\" alt=\"周仓-青龙化力\" /></p>\n<h2 id=\"曹操-逐鹿天下\"><a class=\"anchor\" href=\"#曹操-逐鹿天下\">#</a> 曹操 - 逐鹿天下</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/aUeA9b40tMLmX3n5tIZi6sOrEC9brFqu0zCyHZtP.jpeg\" alt=\"曹操-逐鹿天下\" /></p>\n<h2 id=\"神郭嘉-倚星折月-终极形态\"><a class=\"anchor\" href=\"#神郭嘉-倚星折月-终极形态\">#</a> 神郭嘉 - 倚星折月 - 终极形态</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/ky7OzRF3OHmSltrKlOvGVwZkALhmGKhtfkF9UEwh.jpeg\" alt=\"神郭嘉-倚星折月-终极形态\" /></p>\n<h2 id=\"神郭嘉-倚星折月\"><a class=\"anchor\" href=\"#神郭嘉-倚星折月\">#</a> 神郭嘉 - 倚星折月</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/E4rhS2qUZFCQg6KpIsVkcsTOSlFjkwJvgazJTYD1.jpeg\" alt=\"神郭嘉-倚星折月\" /></p>\n<h2 id=\"周泰-烈火冲杀\"><a class=\"anchor\" href=\"#周泰-烈火冲杀\">#</a> 周泰 - 烈火冲杀</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/XTDq5vMyGErjT5il3UtziXp31pTFtsMqhOT6gNTt.jpeg\" alt=\"周泰-烈火冲杀\" /></p>\n<h2 id=\"小乔-采莲江南\"><a class=\"anchor\" href=\"#小乔-采莲江南\">#</a> 小乔 - 采莲江南</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/BJTKuvl2CiZJXhjN2fRpT7sqIuJj9Zow8Xkyv66m.jpeg\" alt=\"小乔-采莲江南\" /></p>\n<h2 id=\"大乔-衣垂绿川-\"><a class=\"anchor\" href=\"#大乔-衣垂绿川-\">#</a> 大乔 - 衣垂绿川 -</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/UIWYW3QxaPoq5qe9oAMrPXW7eRjyuzqcbhIDR8pw.jpeg\" alt=\"大乔-衣垂绿川-\" /></p>\n<h2 id=\"陆逊-烈火烛天\"><a class=\"anchor\" href=\"#陆逊-烈火烛天\">#</a> 陆逊 - 烈火烛天</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/o9BbZrdbPZ1pSMlZZr3A3nYuH296m0hDaoCRPEUX.jpeg\" alt=\"陆逊-烈火烛天\" /></p>\n<h2 id=\"孙尚香-星流霆击\"><a class=\"anchor\" href=\"#孙尚香-星流霆击\">#</a> 孙尚香 - 星流霆击</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/GV01N2RLPYafpdCKzd5b5Loyz44476hhzeklz4f9.jpeg\" alt=\"孙尚香-星流霆击\" /></p>\n<h2 id=\"关银屏-步步生花\"><a class=\"anchor\" href=\"#关银屏-步步生花\">#</a> 关银屏 - 步步生花</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/GX9UMBsFtZChnFngjPNNsVQuJuA3TRjxfzR3k8VE.jpeg\" alt=\"关银屏-步步生花\" /></p>\n<h2 id=\"秦宓神吕布-冠绝天下\"><a class=\"anchor\" href=\"#秦宓神吕布-冠绝天下\">#</a> 秦宓 &amp; 神吕布 - 冠绝天下</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/7zvbyqfX8sSPkeuwHUb8KgQ5izWHpqEA57WETMxO.jpeg\" alt=\"秦宓&amp;神吕布-冠绝天下\" /></p>\n<h2 id=\"刘赪黄忠-明良千古\"><a class=\"anchor\" href=\"#刘赪黄忠-明良千古\">#</a> 刘赪 &amp; 黄忠 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/6KsY6GsKFaZdY1WKsb1XJfAbyCCXpNVJdqfsATfB.jpeg\" alt=\"刘赪&amp;黄忠-明良千古\" /></p>\n<h2 id=\"李丰-太仓聚粟\"><a class=\"anchor\" href=\"#李丰-太仓聚粟\">#</a> 李丰 - 太仓聚粟</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/iZeZqJJANdmyb2IKGW1dywQtPSuEu8HAbcGj9uoh.jpeg\" alt=\"李丰-太仓聚粟\" /></p>\n<h2 id=\"甘夫人-为君担忧\"><a class=\"anchor\" href=\"#甘夫人-为君担忧\">#</a> 甘夫人 - 为君担忧</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/Ep5DCfSDMRSNjZSnpAwYStLx5CIA3hZfKid4aHiF.jpeg\" alt=\"甘夫人-为君担忧\" /></p>\n<h2 id=\"诸葛瞻-绵竹之殇\"><a class=\"anchor\" href=\"#诸葛瞻-绵竹之殇\">#</a> 诸葛瞻 - 绵竹之殇</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/3SPA2wJ5R3IL8nbaZncvtdzFL52XNRndGSIG8YP7.jpeg\" alt=\"诸葛瞻-绵竹之殇\" /></p>\n<h2 id=\"曹婴-水清濯缨\"><a class=\"anchor\" href=\"#曹婴-水清濯缨\">#</a> 曹婴 - 水清濯缨</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/1xpoJxWaed8wcop0LMqiskbB4SmsYMohrKyapqSa.jpeg\" alt=\"曹婴-水清濯缨\" /></p>\n<h2 id=\"张昌蒲-月下佳人\"><a class=\"anchor\" href=\"#张昌蒲-月下佳人\">#</a> 张昌蒲 - 月下佳人</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/pqhXT0XONQT6oniuPm6QKiMvYI9x1apEVZimwwrj.jpeg\" alt=\"张昌蒲-月下佳人\" /></p>\n<h2 id=\"蔡贞姬-与蝶共舞\"><a class=\"anchor\" href=\"#蔡贞姬-与蝶共舞\">#</a> 蔡贞姬 - 与蝶共舞</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/4Ku8dzet4pub91dMLvuRbfc50TI1qdmlnjAPgMtg.jpeg\" alt=\"蔡贞姬-与蝶共舞\" /></p>\n<h2 id=\"蔡文姬-冠绝天下\"><a class=\"anchor\" href=\"#蔡文姬-冠绝天下\">#</a> 蔡文姬 - 冠绝天下</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/XZkOkoM0YGoNsr21YjeGNl06hsz92NYZ1kEz67hR.jpeg\" alt=\"蔡文姬-冠绝天下\" /></p>\n<h2 id=\"孙权-冠绝天下\"><a class=\"anchor\" href=\"#孙权-冠绝天下\">#</a> 孙权 - 冠绝天下</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/dPHHNYLAGyQEzHh8V8FodAW8Yx2GPmQxm3k5WYqO.jpeg\" alt=\"孙权-冠绝天下\" /></p>\n<h2 id=\"张辽-登峰陷阵\"><a class=\"anchor\" href=\"#张辽-登峰陷阵\">#</a> 张辽 - 登峰陷阵</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/8jzgfkyzAOH7lY7QHHtfH3vIkzQ6cVmNuVCmNeEd.jpeg\" alt=\"张辽-登峰陷阵\" /></p>\n<h2 id=\"曹昂-竭战鳞伤\"><a class=\"anchor\" href=\"#曹昂-竭战鳞伤\">#</a> 曹昂 - 竭战鳞伤</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/oPzlBK7O8sCfY5OoqRK8Utb7lBJtyMOKSxX70tXM.jpeg\" alt=\"曹昂-竭战鳞伤\" /></p>\n<h2 id=\"钟会钟繇-偷酒不拜\"><a class=\"anchor\" href=\"#钟会钟繇-偷酒不拜\">#</a> 钟会 &amp; 钟繇 - 偷酒不拜</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/i7U6YuBge8c2KiuT2lD9nxhiJQjSWK3UG1cl4nUb.jpeg\" alt=\"钟会&amp;钟繇-偷酒不拜\" /></p>\n<h2 id=\"留赞-灵魂歌王\"><a class=\"anchor\" href=\"#留赞-灵魂歌王\">#</a> 留赞 - 灵魂歌王</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/JEtSQUJyknSNvqKBp4XJ4IePmHrKFPpXG3NgeR9d.jpeg\" alt=\"留赞-灵魂歌王\" /></p>\n<h2 id=\"荀彧-驱虎吞狼\"><a class=\"anchor\" href=\"#荀彧-驱虎吞狼\">#</a> 荀彧 - 驱虎吞狼</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/6kLHMKjP3jZWtp0t8cSlACioboZYBapA24br0Bb5.jpeg\" alt=\"荀彧-驱虎吞狼\" /></p>\n<h2 id=\"张飞夏侯氏-明良千古\"><a class=\"anchor\" href=\"#张飞夏侯氏-明良千古\">#</a> 张飞 &amp; 夏侯氏 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/EXOMmWTDI57NmW1mRTAMCKUwai0YoDhCTGlYbvUb.jpeg\" alt=\"张飞&amp;夏侯氏-明良千古\" /></p>\n<h2 id=\"赵云马云禄-明良千古\"><a class=\"anchor\" href=\"#赵云马云禄-明良千古\">#</a> 赵云 &amp; 马云禄 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/Y2dhrrzHYd1v5ruMXG44Jkoq1vkac77uVXI1wJB6.jpeg\" alt=\"赵云&amp;马云禄-明良千古\" /></p>\n<h2 id=\"马超杨婉-明良千古\"><a class=\"anchor\" href=\"#马超杨婉-明良千古\">#</a> 马超 &amp; 杨婉 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/mlyzStnFX3bs7OgGlc4nam5kbQwBPUFp6nuZdZ8G.jpeg\" alt=\"马超&amp;杨婉-明良千古\" /></p>\n<h2 id=\"关羽胡金定-明良千古\"><a class=\"anchor\" href=\"#关羽胡金定-明良千古\">#</a> 关羽 &amp; 胡金定 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/99nRKFYANgV15cUiAmv9j6lmdwqiorIxMvLYgyNj.jpeg\" alt=\"关羽&amp;胡金定-明良千古\" /></p>\n<h2 id=\"戏志才-举棋若定\"><a class=\"anchor\" href=\"#戏志才-举棋若定\">#</a> 戏志才 - 举棋若定</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/6a7f64RfFq7WWoC8L7FUuC2SoZIOJKKu7oOGul58.jpeg\" alt=\"戏志才-举棋若定\" /></p>\n<h2 id=\"郭嘉-梅香如故\"><a class=\"anchor\" href=\"#郭嘉-梅香如故\">#</a> 郭嘉 - 梅香如故</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/SedOsxJkHiKm7mxVjNXoTVX5cu9araUOeYI7L7xn.jpeg\" alt=\"郭嘉-梅香如故\" /></p>\n<h2 id=\"张星彩-临军对阵\"><a class=\"anchor\" href=\"#张星彩-临军对阵\">#</a> 张星彩 - 临军对阵</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/bpklbPfzjASjVETYDIXPpilgBXTGKiYvaUJtN6Oy.jpeg\" alt=\"张星彩-临军对阵\" /></p>\n<h2 id=\"曹冲-聪察岐嶷\"><a class=\"anchor\" href=\"#曹冲-聪察岐嶷\">#</a> 曹冲 - 聪察岐嶷</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/n8noE96tVcY0psl8gP8amk7ScxqCAKq49Ss2Dd8a.jpeg\" alt=\"曹冲-聪察岐嶷\" /></p>\n<h2 id=\"张昭张纮-同心协力\"><a class=\"anchor\" href=\"#张昭张纮-同心协力\">#</a> 张昭张纮 - 同心协力</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/dVLRImpp0hE8Y5tmMtVuROQYilVNbvWmkUbcKPFr.jpeg\" alt=\"张昭张纮-同心协力\" /></p>\n<h2 id=\"黄忠-明良千古\"><a class=\"anchor\" href=\"#黄忠-明良千古\">#</a> 黄忠 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/KKU0VyRJGIPqsEeUFTzbQ3PEf4c27FN5qUpD2iNM.jpeg\" alt=\"黄忠-明良千古\" /></p>\n<h2 id=\"刘赪-明良千古\"><a class=\"anchor\" href=\"#刘赪-明良千古\">#</a> 刘赪 - 明良千古</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/4FPdnmAFwU4C7iy1THlN4SQGnOjyhjjVZpifaxnd.jpeg\" alt=\"刘赪-明良千古\" /></p>\n<h2 id=\"朱然-剑舞枫飞\"><a class=\"anchor\" href=\"#朱然-剑舞枫飞\">#</a> 朱然 - 剑舞枫飞</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/5xk36VyRR2St1AMecOn2YrrVqtReqPUEig5YmQMO.jpeg\" alt=\"朱然-剑舞枫飞\" /></p>\n<h2 id=\"王元姬-莲池戏水\"><a class=\"anchor\" href=\"#王元姬-莲池戏水\">#</a> 王元姬 - 莲池戏水</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/fNEnD7QYnNH7mjDd5OybdpFaxo2965YXbgzwPdU9.jpeg\" alt=\"王元姬-莲池戏水\" /></p>\n<h2 id=\"徐盛-破军杀将\"><a class=\"anchor\" href=\"#徐盛-破军杀将\">#</a> 徐盛 - 破军杀将</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/tLKYW5yN0Vl1HEcVlxm0CSCYIJPI6VTS6lSB3IgB.jpeg\" alt=\"徐盛-破军杀将\" /></p>\n<h2 id=\"花鬘-南蛮公主\"><a class=\"anchor\" href=\"#花鬘-南蛮公主\">#</a> 花鬘 - 南蛮公主</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/At8ex0HLH9fASAAwOZ3wJnKStkYZupa5quDeFY6O.jpeg\" alt=\"花鬘-南蛮公主\" /></p>\n<h2 id=\"曹操-雄吞天下\"><a class=\"anchor\" href=\"#曹操-雄吞天下\">#</a> 曹操 - 雄吞天下</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/S8M9z0qqSenSnaFEMQtspf2l3NZoIcp0S4zWimw5.jpeg\" alt=\"曹操-雄吞天下\" /></p>\n<h2 id=\"张春华-雪中舞刃\"><a class=\"anchor\" href=\"#张春华-雪中舞刃\">#</a> 张春华 - 雪中舞刃</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/YYktjLbiDnQBUZDsW6cZkmHLuAhiW9h3dSvGqEuS.jpeg\" alt=\"张春华-雪中舞刃\" /></p>\n<h1 id=\"佳节庆典\"><a class=\"anchor\" href=\"#佳节庆典\">#</a> 佳节庆典</h1>\n<h2 id=\"2023-兔年清明\"><a class=\"anchor\" href=\"#2023-兔年清明\">#</a> 2023 - 兔年清明</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/lctjEaj2p01piHDg8OKd9tVtsOEHWwgDFYv0bhuV.jpeg\" alt=\"2023-兔年清明\" /></p>\n<h2 id=\"2023-兔年春节\"><a class=\"anchor\" href=\"#2023-兔年春节\">#</a> 2023 - 兔年春节</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/ikkowUajAhK9Uk7rboKZJz1wpXa8TzoNKATs9CXJ.jpeg\" alt=\"2023-兔年春节\" /></p>\n<h2 id=\"2022-虎年端午\"><a class=\"anchor\" href=\"#2022-虎年端午\">#</a> 2022 - 虎年端午</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/BrTa3wVd3dDFyQwH2S8kjVLboGvMnGnPw2Zlbvi1.jpeg\" alt=\"2022-虎年端午\" /></p>\n<h2 id=\"2022-虎年清明\"><a class=\"anchor\" href=\"#2022-虎年清明\">#</a> 2022 - 虎年清明</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/wvS3skEXImOkSWQXWFRVzH0YYpRTrrpqXcr33qJG.jpeg\" alt=\"2022-虎年清明\" /></p>\n<h2 id=\"2022-虎年春节\"><a class=\"anchor\" href=\"#2022-虎年春节\">#</a> 2022 - 虎年春节</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/fQKKAVnoJLZpwTnBltiOMxCv6hEO2gc6tWuBotew.jpeg\" alt=\"2022-虎年春节\" /></p>\n<h2 id=\"2022-虎年冬至\"><a class=\"anchor\" href=\"#2022-虎年冬至\">#</a> 2022 - 虎年冬至</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/3sxttL3ALEJAYB2BfS0CyNMZMvpvFsoL9bUJQlHi.jpeg\" alt=\"2022-虎年冬至\" /></p>\n<h2 id=\"2022-虎年中秋\"><a class=\"anchor\" href=\"#2022-虎年中秋\">#</a> 2022 - 虎年中秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/w4FZ46Tx3mXDzDyPkrss6LoK6HzFVuXZEfmJzQNO.jpeg\" alt=\"2022-虎年中秋\" /></p>\n<h2 id=\"2022-虎年七夕\"><a class=\"anchor\" href=\"#2022-虎年七夕\">#</a> 2022 - 虎年七夕</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/Hgw8HNzW1a4nqrz4lw3eZwBJvEGD9y6NeQ8wIz5M.jpeg\" alt=\"2022-虎年七夕\" /></p>\n<h2 id=\"2021-牛年端午\"><a class=\"anchor\" href=\"#2021-牛年端午\">#</a> 2021 - 牛年端午</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/P3rxF2qCTH6BPwpeJv8Ipg9bafKt1C1sNnq1JOg5.jpeg\" alt=\"2021-牛年端午\" /></p>\n<h2 id=\"2021-牛年立冬\"><a class=\"anchor\" href=\"#2021-牛年立冬\">#</a> 2021 - 牛年立冬</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/ElhwfQp05kzpQsfufxNsiI9xbn5NFzHMymWNB6Um.jpeg\" alt=\"2021-牛年立冬\" /></p>\n<h2 id=\"2021-牛年清明\"><a class=\"anchor\" href=\"#2021-牛年清明\">#</a> 2021 - 牛年清明</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/MaWTO2Lfg3AUQLFZATwf0ZRaK1GUVaWx6TG3TYeM.jpeg\" alt=\"2021-牛年清明\" /></p>\n<h2 id=\"2021-牛年春节\"><a class=\"anchor\" href=\"#2021-牛年春节\">#</a> 2021 - 牛年春节</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/hNLj3eOgnNRduaiTaKB561xz4u2lheRLuBrzTe1a.jpeg\" alt=\"2021-牛年春节\" /></p>\n<h2 id=\"2021-牛年中秋\"><a class=\"anchor\" href=\"#2021-牛年中秋\">#</a> 2021 - 牛年中秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/riIctvg39IAWHzMEl553CAUUoDSSeL6fisQGY00l.jpeg\" alt=\"2021-牛年中秋\" /></p>\n<h2 id=\"2021-牛年七夕\"><a class=\"anchor\" href=\"#2021-牛年七夕\">#</a> 2021 - 牛年七夕</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/yvpkRrr1ObYVLnl4I5uf4Oi9pk235yQv9DJvcqSQ.jpeg\" alt=\"2021-牛年七夕\" /></p>\n<h2 id=\"2020-鼠年端午\"><a class=\"anchor\" href=\"#2020-鼠年端午\">#</a> 2020 - 鼠年端午</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/NLiwLUOqSvdeA895OmP7hOUAywOQn2GAYAZEMj49.jpeg\" alt=\"2020-鼠年端午\" /></p>\n<h2 id=\"2020-鼠年春节\"><a class=\"anchor\" href=\"#2020-鼠年春节\">#</a> 2020 - 鼠年春节</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/SC6Gff4kBUBYpRuJMZi6KZjBivyOWpHcNnDix3EL.jpeg\" alt=\"2020-鼠年春节\" /></p>\n<h2 id=\"2020-鼠年春分\"><a class=\"anchor\" href=\"#2020-鼠年春分\">#</a> 2020 - 鼠年春分</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/worXkCcp5dphxpidUe1TIAiavQJDDhbObr0RNa7k.jpeg\" alt=\"2020-鼠年春分\" /></p>\n<h2 id=\"2020-鼠年冬至\"><a class=\"anchor\" href=\"#2020-鼠年冬至\">#</a> 2020 - 鼠年冬至</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/fX1DeBOFD14MngMPvE149WZViVqu7e1HFWhuG0mv.jpeg\" alt=\"2020-鼠年冬至\" /></p>\n<h2 id=\"2020-鼠年中秋\"><a class=\"anchor\" href=\"#2020-鼠年中秋\">#</a> 2020 - 鼠年中秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/a7IB2yjBkUmPnEwPODG4RFAx2LItbpaWDmtiAnia.jpeg\" alt=\"2020-鼠年中秋\" /></p>\n<h2 id=\"2020-鼠年七夕\"><a class=\"anchor\" href=\"#2020-鼠年七夕\">#</a> 2020 - 鼠年七夕</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/kYUTaW3FXRE3Ym4HRYreua3ONOAJupM254dXQbpp.jpeg\" alt=\"2020-鼠年七夕\" /></p>\n<h2 id=\"2019-猪年端午\"><a class=\"anchor\" href=\"#2019-猪年端午\">#</a> 2019 - 猪年端午</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/tSvH2ESL6b3PI9GqsJTsQeYvS3dmPotGEERyeI4o.jpeg\" alt=\"2019-猪年端午\" /></p>\n<h2 id=\"2019-猪年大雪\"><a class=\"anchor\" href=\"#2019-猪年大雪\">#</a> 2019 - 猪年大雪</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/D8hjEs5pP5Fc87VaS4uni4xDTPZy32DUybyIVU92.jpeg\" alt=\"2019-猪年大雪\" /></p>\n<h2 id=\"2019-猪年圣诞\"><a class=\"anchor\" href=\"#2019-猪年圣诞\">#</a> 2019 - 猪年圣诞</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/iIcKQO5lFSCI4wRdKQfbBs8TeWEU6iRYeCi6FPdM.jpeg\" alt=\"2019-猪年圣诞\" /></p>\n<h2 id=\"2019-猪年中秋\"><a class=\"anchor\" href=\"#2019-猪年中秋\">#</a> 2019 - 猪年中秋</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/7fVIxnF8vuY974URODtLxMNdGGe1RuP4Q9GqO1iM.jpeg\" alt=\"2019-猪年中秋\" /></p>\n<h2 id=\"2019-猪年七夕\"><a class=\"anchor\" href=\"#2019-猪年七夕\">#</a> 2019 - 猪年七夕</h2>\n<p><img data-src=\"https://www.sanguosha.cn/storage/uploads/images/bRKj32LVpBD2hdpn1nLkFqNsmT8J7pnGU8OxbDhj.jpeg\" alt=\"2019-猪年七夕\" /></p>\n",
            "tags": [
                "三国杀"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/08/22/2023-08-%E7%BD%97%E7%BF%94%E8%B0%88%E3%80%8A%E9%87%8D%E5%88%91%E4%B8%BB%E4%B9%89%E3%80%8B/",
            "url": "https://haust-kevin.github.io/2023/08/22/2023-08-%E7%BD%97%E7%BF%94%E8%B0%88%E3%80%8A%E9%87%8D%E5%88%91%E4%B8%BB%E4%B9%89%E3%80%8B/",
            "title": "罗翔说刑法：重刑主义",
            "date_published": "2023-08-21T16:00:01.000Z",
            "content_html": "<div class=\"note primary\">\n<p>罗翔说刑法：《【罗翔】网络判案，人均死刑？聊聊重刑主义》的概要和观后总结</p>\n</div>\n<h1 id=\"原视频\"><a class=\"anchor\" href=\"#原视频\">#</a> 原视频</h1>\n<ul>\n<li>视频名称：【罗翔】网络判案，人均死刑？聊聊重刑主义</li>\n<li>视频链接： <code>https://www.bilibili.com/video/BV1Ep4y1J7mk</code></li>\n<li>直达视频：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUVwNHkxSjdtaw==\">【罗翔】网络判案，人均死刑？聊聊重刑主义</span></li>\n</ul>\n<h1 id=\"视频精简\"><a class=\"anchor\" href=\"#视频精简\">#</a> 视频精简</h1>\n<h2 id=\"案例引出\"><a class=\"anchor\" href=\"#案例引出\">#</a> 案例引出</h2>\n<p>夏某在汪某家进行施工，发现汪某家有两朵好看的花，便挖走种回了自己家，汪某发现后报了警，经价值认定中心认定，两朵花属于名贵花卉，价值 70,000。<br />\n在该盗窃案中存在的数额问题上，由于夏某主观上认为两朵花只值几百甚至几十块钱，而客观上两朵花价值 70,000，其中存在了认知问题，而如何定该案件的盗窃数额属于刑法学需要讨论的问题。</p>\n<h2 id=\"重刑主义\"><a class=\"anchor\" href=\"#重刑主义\">#</a> 重刑主义</h2>\n<p>很多人认为：“为什么老是为犯罪人说话呢？为犯罪人说话就是对被害人不公平！”。<br />\n罗老师讲到：<strong>如果不加区分一律重刑。事后其实是可能会鼓励犯罪的</strong>。犯罪者容易产生亡徒思想。如果盗窃一万元一律死刑，那么偷窃一万的罪犯可能盗窃更多，甚至杀人越货，杀 100 个人，反正是一死。<br />\n刑法的三大原则：<strong>罪行法定</strong>，<strong>刑法面前人人平等</strong>、<strong>罪行相当</strong>。<br />\n“重罪者，人之所难犯也。而小过者，人之所易去也。使人去其所易，无离其所难。此治之道。夫小过不生，大罪不治，世人无罪而乱不生也。--《韩非子・内储说上七术》”<br />\n 韩非子认为：重罪人一般很难犯，轻罪人们容易犯，如果用严重的刑罚来惩罚犯轻罪的人，那么人们便不敢去试试犯罪，刑罚的目的是为了威慑，最终达到一个理想状态 —— 没有刑罚。<br />\n韩非子也写道：“灰于公道者断其手”，很多人无法理解，为什么扔垃圾要剁手。孔子也只能勉强解释道：“无气灰所意者，断手所悟也行，所以不观所悟。古人以为矣，故行之。” 这段话很难翻成白话文，就是不乱扔垃圾是很容易做到的，但是断手会令人感到巨大的痛苦，那如果干了一件很容易的事情，就可以避免严重的惩罚，古人认为这是容易做到的，所以实施这种刑法。<br />\n另有记载，把灰倒在大马路上，会让灰尘到处乱飞，人就会生气，一生气就可能斗殴，斗殴的结果就可能会让家族之间互相残杀。所以随便在马路上倒垃圾是残害家族的行为，那因此对其重刑，事后也是可以接受的。</p>\n<h3 id=\"支持重刑主义的观点\"><a class=\"anchor\" href=\"#支持重刑主义的观点\">#</a> 支持重刑主义的观点</h3>\n<p>支持者认为，严厉的刑罚能够有效地威慑潜在犯罪行为，保护社会的安全和秩序。他们强调刑罚的公平和正义，认为罪犯应当为其所犯下的罪行付出代价。他们可能认为，对严重犯罪采取重型刑罚能够有效阻止犯罪人的行为，从而减少社会的不安定因素。</p>\n<h3 id=\"反对重刑主义的观点\"><a class=\"anchor\" href=\"#反对重刑主义的观点\">#</a> 反对重刑主义的观点</h3>\n<p>反对者可能认为，过度的重型刑罚并不能真正解决问题，反而可能导致不公平和严重的人权侵害。他们强调人道主义，认为刑罚应当以人的尊严为前提，避免过度的痛苦和苦难。此外，他们也可能关注到刑罚的社会成本，认为长期监禁或死刑等刑罚在执行上需要大量资源，可能并不能达到预期的威慑效果。</p>\n<h2 id=\"刑罚正当化\"><a class=\"anchor\" href=\"#刑罚正当化\">#</a> 刑罚正当化</h2>\n<p>关于刑罚的正当化，根据一直有两种争论，一种观点认为因为有了犯罪，所以要有刑罚。<br />\n另一种观点认为没有犯罪，所以需要刑罚。</p>\n<h3 id=\"报应主义\"><a class=\"anchor\" href=\"#报应主义\">#</a> 报应主义</h3>\n<p>立足既往，认为罪犯实施犯罪本身就应该受到惩罚。有了犯罪，需要刑罚。<br />\n善有善报，恶有恶报吗？惩罚具有道德上的正当性。如果严重的谋杀者不被判处死刑，那么被害人的家属也可能会走向复仇之路。<br />\n报应主义还体现了对人的尊重，它既是对犯罪人的尊重，也是对被害人的尊重。犯罪人出于自由意志选择了犯罪，他也就预见了行为的后果，为了尊重他理性的选择，就要让他承担他所预见的后果。<br />\n犯罪人亵渎了被害的人格和尊严，刑罚也必须纠正这种错误的思想，所以通过对犯罪的惩罚也可以恢复被害人被践踏的尊严。<br />\n康德认为，重刑主义的过度威慑，把人当成纯粹的工具吓人，是对刑罚的滥用。<br />\n黑格尔认为，重型主义也没有尊重犯罪人作为理性的存在，犯罪人理性上知道自己犯法会受到刑罚，所以处罚他正是尊重他是理性的存在。</p>\n<h3 id=\"功利主义\"><a class=\"anchor\" href=\"#功利主义\">#</a> 功利主义</h3>\n<p>关注将来，惩罚是为了预防。<br />\n人都有趋利避害的本能，在行为之前，人们会权衡利弊，比较犯罪带来的快乐，所遭受刑罚可能带来痛苦，如果结论是刑罚的痛苦大于犯罪的乐趣，他们就不会去实施犯罪。</p>\n<h4 id=\"一般预防\"><a class=\"anchor\" href=\"#一般预防\">#</a> 一般预防</h4>\n<p>一般预防就是所谓的杀鸡给猴看，对犯罪人施加惩罚，是为了<strong>威吓社会公众，让他们不要以身试法</strong>，它把所有公民群体当做潜在的犯罪人。<br />\n一般预防认为法律应该以最小的社会痛苦追求社会福利的最大化。犯罪和刑罚都会给社会带来痛苦。那如果刑罚的痛苦小于犯罪的痛苦，但却能防止更多的犯罪，那么刑罚就是正当的。刑罚之恶不能超过犯罪之恶，多余的刑罚就是多余的恶。</p>\n<h4 id=\"特殊预防\"><a class=\"anchor\" href=\"#特殊预防\">#</a> 特殊预防</h4>\n<p>特殊预防那针对的是犯罪人本人，防止他们再次犯罪，比如说对他们进行教育改造，让犯罪人能够回归社会。<br />\n特殊预防不再将社会公众视为潜在的犯罪人，把他们纯粹作为恐吓的对象，而是把他们作为守法的公民，每一次对罪犯的惩罚都是为了强化民众发自内心的守法意思。<br />\n特殊预防<strong>强调剥夺罪犯的再犯能力，让其积极的回归社会</strong></p>\n<h2 id=\"结尾\"><a class=\"anchor\" href=\"#结尾\">#</a> 结尾</h2>\n<p>如果你弃灰于路，你或你的家人是否接受替罪羊的名义？或者你或你的家人是否依然为剁手法点赞？法律的生命是经验而非逻辑，没有人拥有完全的理性，因此也不可能在理性上被彻底说服。人类各个世代千千万万的人，从个人经验中所汇总的海量知识，那肯定大于我们这些自诩为法律专家的狭小知识。还是刚才所说的所有的专业知识，其实都是小众一见，但是我们依然有责任说出我们自己专业的小众意见。法律没有最优解，只能提供一个相对较好或者说不坏的解决方案。</p>\n<h1 id=\"个人总结\"><a class=\"anchor\" href=\"#个人总结\">#</a> 个人总结</h1>\n<p>重刑主义在某些情况下可能会有一定的合理性，但需要在法律、伦理和社会效益之间进行权衡和取舍。刑罚政策应当充分考虑社会的多样性和复杂性，以建立更加公正、有效和平衡的刑法体系。<br />\n回顾刑罚合理性与个体权益的平衡，我不禁思考法治的作用。法治并不会创造完美的社会，但它可以防止最坏的情况发生，我们需要在权衡中找到最为合适的折中方案。这引导我深入思考刑罚与人性、公正、社会秩序的关系，以及法律应如何在社会中发挥作用。</p>\n",
            "tags": [
                "人文社科",
                "罗翔说刑法"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/08/20/2023-08-%E7%8B%82%E4%BA%BA%E6%97%A5%E8%AE%B0/",
            "url": "https://haust-kevin.github.io/2023/08/20/2023-08-%E7%8B%82%E4%BA%BA%E6%97%A5%E8%AE%B0/",
            "title": "狂人日记",
            "date_published": "2023-08-20T12:02:57.000Z",
            "content_html": "<div class=\"note primary\">\n<p>重温《狂人日记》，就像是重新穿越时光回到了一个扑朔迷离的内心世界。每一段都是对人性深刻探索的旅程，通过主人公的独白，我们能感受到他内心的冲突、挣扎和反思。作品以幽默的笔触揭示了社会的荒谬，同时也展示了个体在困境中的无奈。在这片文字的海洋中，我们或许能找到一丝启示，一个更加清晰的思考角度，甚至是对现实的勇敢直面。《狂人日记》不仅仅是一部文学作品，更是一次对自我和社会的深刻审视，值得每个人在不同的生命阶段多次品味。无论是初读还是再读，它都能带给我们新的领悟和共鸣，让我们更加深刻地思考人性与世界，即使《狂人日记》的著作环境已是百年前，仍能带给我们无比的震撼。</p>\n</div>\n<h1 id=\"全文\"><a class=\"anchor\" href=\"#全文\">#</a> 全文</h1>\n<h2 id=\"序言\"><a class=\"anchor\" href=\"#序言\">#</a> 序言</h2>\n<blockquote>\n<p>某君昆仲，今隐其名，皆余昔日在中学时良友；分隔多年，消息渐阙。日前偶闻其一大病；适归故乡，迂道往访，则仅晤一人，言病者其弟也。劳君远道来视，然已早愈，赴某地候补矣。因大笑，出示日记二册，谓可见当日病状，不妨献诸旧友。持归阅一过，知所患盖 “迫害狂” 之类。语颇错杂无伦次，又多荒唐之言；亦不著月日，惟墨色字体不一，知非一时所书。间亦有略具联络者，今撮录一篇，以供医家研究。记中语误，一字不易；惟人名虽皆村人，不为世间所知，无关大体，然亦悉易去。至于书名，则本人愈后所题，不复改也。七年四月二日识。</p>\n</blockquote>\n<h2 id=\"第一话\"><a class=\"anchor\" href=\"#第一话\">#</a> 第一话</h2>\n<p>今天晚上，很好的月光。<br />\n我不见他，已是三十多年；今天见了，精神分外爽快。才知道以前的三十多年，全是发昏；然而须十分小心。不然，那赵家的狗，何以看我两眼呢？<br />\n我怕得有理。</p>\n<h2 id=\"第二话\"><a class=\"anchor\" href=\"#第二话\">#</a> 第二话</h2>\n<p>今天全没月光，我知道不妙。早上小心出门，赵贵翁的眼色便怪：似乎怕我，似乎想害我。还有七八个人，交头接耳的议论我，张着嘴，对我笑了一笑；我便从头直冷到脚根，晓得他们布置，都已妥当了。<br />\n我可不怕，仍旧走我的路。前面一伙小孩子，也在那里议论我；眼色也同赵贵翁一样，脸色也铁青。我想我同小孩子有什么仇，他也这样。忍不住大声说，“你告诉我！” 他们可就跑了。<br />\n我想：我同赵贵翁有什么仇，同路上的人又有什么仇；只有廿年以前，把古久先生的陈年流水簿子，踹了一脚，古久先生很不高兴。赵贵翁虽然不认识他，一定也听到风声，代抱不平；约定路上的人，同我作冤对。但是小孩子呢？那时候，他们还没有出世，何以今天也睁着怪眼睛，似乎怕我，似乎想害我。这真教我怕，教我纳罕而且伤心。<br />\n我明白了。这是他们娘老子教的！</p>\n<h2 id=\"第三话\"><a class=\"anchor\" href=\"#第三话\">#</a> 第三话</h2>\n<p>晚上总是睡不着。凡事须得研究，才会明白。<br />\n他们 —— 也有给知县打枷过的，也有给绅士掌过嘴的，也有衙役占了他妻子的，也有老子娘被债主逼死的；他们那时候的脸色，全没有昨天这么怕，也没有这么凶。<br />\n最奇怪的是昨天街上的那个女人，打他儿子，嘴里说道，“老子呀！我要咬你几口才出气！” 他眼睛却看着我。我出了一惊，遮掩不住；那青面獠牙的一伙人，便都哄笑起来。陈老五赶上前，硬把我拖回家中了。<br />\n拖我回家，家里的人都装作不认识我；他们的脸色，也全同别人一样。进了书房，便反扣上门，宛然是关了一只鸡鸭。这一件事，越教我猜不出底细。<br />\n前几天，狼子村的佃户来告荒，对我大哥说，他们村里的一个大恶人，给大家打死了；几个人便挖出他的心肝来，用油煎炒了吃，可以壮壮胆子。我插了一句嘴，佃户和大哥便都看我几眼。今天才晓得他们的眼光，全同外面的那伙人一模一样。<br />\n想起来，我从顶上直冷到脚跟。<br />\n他们会吃人，就未必不会吃我。<br />\n你看那女人 “咬你几口” 的话，和一伙青面獠牙人的笑，和前天佃户的话，明明是暗号。我看出他话中全是毒，笑中全是刀。他们的牙齿，全是白厉厉的排着，这就是吃人的家伙。<br />\n照我自己想，虽然不是恶人，自从踹了古家的簿子，可就难说了。他们似乎别有心思，我全猜不出。况且他们一翻脸，便说人是恶人。我还记得大哥教我做论，无论怎样好人，翻他几句，他便打上几个圈；原谅坏人几句，他便说 “翻天妙手，与众不同”。我那里猜得到他们的心思，究竟怎样；况且是要吃的时候。<br />\n凡事总须研究，才会明白。古来时常吃人，我也还记得，可是不甚清楚。我翻开历史一查，这历史没有年代，歪歪斜斜的每叶上都写着 “仁义道德” 几个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是 “吃人”！<br />\n书上写着这许多字，佃户说了这许多话，却都笑吟吟的睁着怪眼看我。<br />\n我也是人，他们想要吃我了！</p>\n<h2 id=\"第四话\"><a class=\"anchor\" href=\"#第四话\">#</a> 第四话</h2>\n<p>早上，我静坐了一会儿。陈老五送进饭来，一碗菜，一碗蒸鱼；这鱼的眼睛，白而且硬，张着嘴，同那一伙想吃人的人一样。吃了几筷，滑溜溜的不知是鱼是人，便把他兜肚连肠的吐出。<br />\n我说 “老五，对大哥说，我闷得慌，想到园里走走。” 老五不答应，走了；停一会，可就来开了门。<br />\n我也不动，研究他们如何摆布我；知道他们一定不肯放松。果然！我大哥引了一个老头子，慢慢走来；他满眼凶光，怕我看出，只是低头向着地，从眼镜横边暗暗看我。大哥说，“今天你仿佛很好。” 我说 “是的。” 大哥说，“今天请何先生来，给你诊一诊。” 我说 “可以！” 其实我岂不知道这老头子是刽子手扮的！无非借了看脉这名目，揣一揣肥瘠：因这功劳，也分一片肉吃。我也不怕；虽然不吃人，胆子却比他们还壮。伸出两个拳头，看他如何下手。老头子坐着，闭了眼睛，摸了好一会，呆了好一会；便张开他鬼眼睛说，“不要乱想。静静的养几天，就好了。”<br />\n 不要乱想，静静的养！养肥了，他们是自然可以多吃；我有什么好处，怎么会 “好了”？他们这群人，又想吃人，又是鬼鬼祟祟，想法子遮掩，不敢直截下手，真要令我笑死。我忍不住，便放声大笑起来，十分快活。自己晓得这笑声里面，有的是义勇和正气。老头子和大哥，都失了色，被我这勇气正气镇压住了。<br />\n但是我有勇气，他们便越想吃我，沾光一点这勇气。老头子跨出门，走不多远，便低声对大哥说道，“赶紧吃罢！” 大哥点点头。原来也有你！这一件大发见，虽似意外，也在意中：合伙吃我的人，便是我的哥哥！<br />\n吃人的是我哥哥！<br />\n我是吃人的人的兄弟！<br />\n我自己被人吃了，可仍然是吃人的人的兄弟！</p>\n<h2 id=\"第五话\"><a class=\"anchor\" href=\"#第五话\">#</a> 第五话</h2>\n<p>这几天是退一步想：假使那老头子不是刽子手扮的，真是医生，也仍然是吃人的人。他们的祖师李时珍做的 “本草什么” 上，明明写着人肉可以煎吃；他还能说自己不吃人么？<br />\n至于我家大哥，也毫不冤枉他。他对我讲书的时候，亲口说过可以 “易子而食”；又一回偶然议论起一个不好的人，他便说不但该杀，还当 “食肉寝皮”。我那时年纪还小，心跳了好半天。前天狼子村佃户来说吃心肝的事，他也毫不奇怪，不住的点头。可见心思是同从前一样狠。既然可以 “易子而食”，便什么都易得，什么人都吃得。我从前单听他讲道理，也糊涂过去；现在晓得他讲道理的时候，不但唇边还抹着人油，而且心里满装着吃人的意思。</p>\n<h2 id=\"第六话\"><a class=\"anchor\" href=\"#第六话\">#</a> 第六话</h2>\n<p>黑漆漆的，不知是日是夜。赵家的狗又叫起来了。<br />\n狮子似的凶心，兔子的怯弱，狐狸的狡猾，……</p>\n<h2 id=\"第七话\"><a class=\"anchor\" href=\"#第七话\">#</a> 第七话</h2>\n<p>我晓得他们的方法，直捷杀了，是不肯的，而且也不敢，怕有祸祟。所以他们大家连络，布满了罗网，逼我自戕。试看前几天街上男女的样子，和这几天我大哥的作为，便足可悟出八九分了。最好是解下腰带，挂在梁上，自己紧紧勒死；他们没有杀人的罪名，又偿了心愿，自然都欢天喜地的发出一种呜呜咽咽的笑声。否则惊吓忧愁死了，虽则略瘦，也还可以首肯几下。<br />\n他们是只会吃死肉的！—— 记得什么书上说，有一种东西，叫 “海乙那” 的，眼光和样子都很难看；时常吃死肉，连极大的骨头，都细细嚼烂，咽下肚子去，想起来也教人害怕。“海乙那” 是狼的亲眷，狼是狗的本家。前天赵家的狗，看我几眼，可见他也同谋，早已接洽。老头子眼看着地，岂能瞒得我过。<br />\n最可怜的是我的大哥，他也是人，何以毫不害怕；而且合伙吃我呢？还是历来惯了，不以为非呢？还是丧了良心，明知故犯呢？<br />\n我诅咒吃人的人，先从他起头；要劝转吃人的人，也先从他下手。</p>\n<h2 id=\"第八话\"><a class=\"anchor\" href=\"#第八话\">#</a> 第八话</h2>\n<p>其实这种道理，到了现在，他们也该早已懂得，……<br />\n 忽然来了一个人；年纪不过二十左右，相貌是不很看得清楚，满面笑容，对了我点头，他的笑也不像真笑。我便问他，“吃人的事，对么？” 他仍然笑着说，“不是荒年，怎么会吃人。” 我立刻就晓得，他也是一伙，喜欢吃人的；便自勇气百倍，偏要问他。<br />\n“对么？”<br />\n“这等事问他什么。你真会…… 说笑话。…… 今天天气很好。”<br />\n 天气是好，月色也很亮了。可是我要问你，“对么？”<br />\n 他不以为然了。含含胡胡的答道，“不……”<br />\n“不对？他们何以竟吃？！”<br />\n“没有的事……”<br />\n“没有的事？狼子村现吃；还有书上都写着，通红斩新！”<br />\n 他便变了脸，铁一般青。睁着眼说，“有许有的，这是从来如此……”<br />\n“从来如此，便对么？”<br />\n“我不同你讲这些道理；总之你不该说，你说便是你错！”<br />\n 我直跳起来，张开眼，这人便不见了。全身出了一大片汗。他的年纪，比我大哥小得远，居然也是一伙；这一定是他娘老子先教的。还怕已经教给他儿子了；所以连小孩子，也都恶狠狠的看我。</p>\n<h2 id=\"第九话\"><a class=\"anchor\" href=\"#第九话\">#</a> 第九话</h2>\n<p>自己想吃人，又怕被别人吃了，都用着疑心极深的眼光，面面相觑。……<br />\n 去了这心思，放心做事走路吃饭睡觉，何等舒服。这只是一条门槛，一个关头。他们可是父子兄弟夫妇朋友师生仇敌和各不相识的人，都结成一伙，互相劝勉，互相牵掣，死也不肯跨过这一步。</p>\n<h2 id=\"第十话\"><a class=\"anchor\" href=\"#第十话\">#</a> 第十话</h2>\n<p>大清早，去寻我大哥；他立在堂门外看天，我便走到他背后，拦住门，格外沉静，格外和气的对他说，<br />\n“大哥，我有话告诉你。”<br />\n“你说就是，” 他赶紧回过脸来，点点头。<br />\n“我只有几句话，可是说不出来。大哥，大约当初野蛮的人，都吃过一点人。后来因为心思不同，有的不吃人了，一味要好，便变了人，变了真的人。有的却还吃，—— 也同虫子一样，有的变了鱼鸟猴子，一直变到人。有的不要好，至今还是虫子。这吃人的人比不吃人的人，何等惭愧。怕比虫子的惭愧猴子，还差得很远很远。<br />\n“易牙蒸了他儿子，给桀纣吃，还是一直从前的事。谁晓得从盘古开辟天地以后，一直吃到易牙的儿子；从易牙的儿子，一直吃到徐锡林；从徐锡林，又一直吃到狼子村捉住的人。去年城里杀了犯人，还有一个生痨病的人，用馒头蘸血舐。<br />\n“他们要吃我，你一个人，原也无法可想；然而又何必去入伙。吃人的人，什么事做不出；他们会吃我，也会吃你，一伙里面，也会自吃。但只要转一步，只要立刻改了，也就是人人太平。虽然从来如此，我们今天也可以格外要好，说是不能！大哥，我相信你能说，前天佃户要减租，你说过不能。”<br />\n 当初，他还只是冷笑，随后眼光便凶狠起来，一到说破他们的隐情，那就满脸都变成青色了。大门外立着一伙人，赵贵翁和他的狗，也在里面，都探头探脑的挨进来。有的是看不出面貌，似乎用布蒙着；有的是仍旧青面獠牙，抿着嘴笑。我认识他们是一伙，都是吃人的人。可是也晓得他们心思很不一样，一种是以为从来如此，应该吃的；一种是知道不该吃，可是仍然要吃，又怕别人说破他，所以听了我的话，越发气愤不过，可是抿着嘴冷笑。<br />\n这时候，大哥也忽然显出凶相，高声喝道，“都出去！疯子有什么好看！”<br />\n 这时候，我又懂得一件他们的巧妙了。他们岂但不肯改，而且早已布置；预备下一个疯子的名目罩上我。将来吃了，不但太平无事，怕还会有人见情。佃户说的大家吃了一个恶人，正是这方法。这是他们的老谱！<br />\n陈老五也气愤愤的直走进来。如何按得住我的口，我偏要对这伙人说，“你们可以改了，从真心改起！要晓得将来容不得吃人的人，活在世上。<br />\n“你们要不改，自己也会吃尽。即使生得多，也会给真的人除灭了，同猎人打完狼子一样！—— 同虫子一样！”<br />\n 那一伙人，都被陈老五赶走了。大哥也不知那里去了。陈老五劝我回屋子里去。屋里面全是黑沉沉的。横梁和椽子都在头上发抖；抖了一会，就大起来，堆在我身上。<br />\n万分沉重，动弹不得；他的意思是要我死。我晓得他的沉重是假的，便挣扎出来，出了一身汗。可是偏要说，“你们立刻改了，从真心改起！你们要晓得将来是容不得吃人的人，……”</p>\n<h2 id=\"第十一话\"><a class=\"anchor\" href=\"#第十一话\">#</a> 第十一话</h2>\n<p>太阳也不出，门也不开，日日是两顿饭。<br />\n我捏起筷子，便想起我大哥；晓得妹子死掉的缘故，也全在他。那时我妹子才五岁，可爱可怜的样子，还在眼前。母亲哭个不住，他却劝母亲不要哭；大约因为自己吃了，哭起来不免有点过意不去。如果还能过意不去，…… 妹子是被大哥吃了，母亲知道没有，我可不得而知。<br />\n母亲想也知道；不过哭的时候，却并没有说明，大约也以为应当的了。记得我四五岁时，坐在堂前乘凉，大哥说爷娘生病，做儿子的须割下一片肉来，煮熟了请他吃，才算好人；母亲也没有说不行。一片吃得，整个的自然也吃得。但是那天的哭法，现在想起来，实在还教人伤心，这真是奇极的事！</p>\n<h2 id=\"第十二话\"><a class=\"anchor\" href=\"#第十二话\">#</a> 第十二话</h2>\n<p>不能想了。<br />\n四千年来时时吃人的地方，今天才明白，我也在其中混了多年；大哥正管着家务，妹子恰恰死了，他未必不和在饭菜里，暗暗给我们吃。<br />\n我未必无意之中，不吃了我妹子的几片肉，现在也轮到我自己，…… 有了四千年吃人履历的我，当初虽然不知道，现在明白，难见真的人！</p>\n<h2 id=\"第十三话\"><a class=\"anchor\" href=\"#第十三话\">#</a> 第十三话</h2>\n<p>没有吃过人的孩子，或者还有？<br />\n救救孩子……</p>\n<p>一九一八年四月。</p>\n",
            "tags": [
                "好文摘抄",
                "小说",
                "鲁迅"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/08/19/2023-08-docker-container-2-image/",
            "url": "https://haust-kevin.github.io/2023/08/19/2023-08-docker-container-2-image/",
            "title": "Docker：容器备份",
            "date_published": "2023-08-19T06:33:40.000Z",
            "content_html": "<div class=\"note primary\">\n<p>将 docker 容器打包成镜像并在另一台服务器上运行</p>\n</div>\n<p>1️⃣ 将容器打包成镜像</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> commit <span class=\"token operator\">&lt;</span>container-name<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>image-name<span class=\"token operator\">></span><span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># example: docker commit myblog hexo-blog</span></pre></td></tr></table></figure><p>会在本地生成一个新的 docker 镜像，可以通过 <code>docker images</code>  命令查看生成的镜像。</p>\n<div class=\"note warning\">\n<p>打包时，容器挂的目录 / 文件不会被打包进镜像。解决方案：① 在打包前为挂载的目录生成一份 copy，在另一台机器运行时你需要挂载这份 copy。② 将挂载的目录 copy 至新机器。如果打包后的镜像只需在当前服务器运行，则不需要考虑这个问题。</p>\n</div>\n<p>2️⃣ 将镜像打包成文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> save <span class=\"token parameter variable\">-o</span> <span class=\"token operator\">&lt;</span>outfile<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>image-name<span class=\"token operator\">></span><span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># example: docker save -o blog.jar hexo-blog</span></pre></td></tr></table></figure><p>会在当前目录生成 <code>blog.jar</code>  文件。</p>\n<p>3️⃣ 将打包生成的文件上传至另一台服务器<br />\n使用 scp 命令或者 ssh 工具将 <code>blog.jar</code>  复制到另一台服务器。</p>\n<p>4️⃣ 新机器载入镜像</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> load <span class=\"token parameter variable\">--input</span> <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># example: docker load --input blog.jar</span></pre></td></tr></table></figure><p>会在新机器生成一个新的 docker 镜像，可以通过 <code>docker images</code>  命令查看生成的镜像。</p>\n<p>5️⃣ 运行容器<br />\n导入镜像后就可以进行正常 <code>docker run</code>  命令了。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-itd</span> <span class=\"token parameter variable\">--name</span> <span class=\"token operator\">&lt;</span>container-name<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>image-name<span class=\"token operator\">></span><span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># example: docker run -itd --name myblog hexo-blog</span></pre></td></tr></table></figure><div class=\"note success\">\n<p>备份并导入完成</p>\n</div>\n",
            "tags": [
                "Linux",
                "Docker",
                "Linux"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/08/17/2023-08-brew-replace-download-source/",
            "url": "https://haust-kevin.github.io/2023/08/17/2023-08-brew-replace-download-source/",
            "title": "HomeBrew：brew 更换下载源",
            "date_published": "2023-08-17T07:48:34.000Z",
            "content_html": "<div class=\"note primary\">\n<p>brew 更换下载镜像以提升下载速度</p>\n</div>\n<p>1️⃣ 更换下载源为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9taXJyb3JzLnVzdGMuZWR1LmNuLw==\">中国科学技术大学镜像站</span></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 新建 homebrew-cask 文件夹，若已经存在则无需新建</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>/Library/Taps/homebrew/homebrew-cask\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 将三个目录作为安全目录目录添加到全局的 Git 配置中</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> <span class=\"token parameter variable\">--add</span> safe.directory <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> <span class=\"token parameter variable\">--add</span> safe.directory <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>/Library/Taps/homebrew/homebrew-core\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> <span class=\"token parameter variable\">--add</span> safe.directory <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>/Library/Taps/homebrew/homebrew-cask\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 更新 Homebrew</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>\"</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">git</span> remote set-url origin https://mirrors.ustc.edu.cn/brew.git</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 更新 Homebrew-core</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>/Library/Taps/homebrew/homebrew-core\"</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">git</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># 更新 Homebrew-cask</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span>brew <span class=\"token parameter variable\">--repo</span><span class=\"token variable\">)</span></span>/Library/Taps/homebrew/homebrew-cask\"</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token function\">git</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</pre></td></tr></table></figure><p>2️⃣ 选择 zsh 或 bash 用户，执行即可</p>\n<ul>\n<li>bash 用户<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/'</span> <span class=\"token operator\">>></span> ~/.bash_profile</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">source</span> ~/.bash_profile</pre></td></tr></table></figure></li>\n<li>zsh 用户<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/'</span> <span class=\"token operator\">>></span> ~/.zshrc</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">source</span> ~/.zshrc</pre></td></tr></table></figure></li>\n</ul>\n<p>3️⃣ 更新 brew</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>brew update <span class=\"token parameter variable\">-v</span></pre></td></tr></table></figure><div class=\"note success\">\n<p>配置完成</p>\n</div>\n",
            "tags": [
                "Linux",
                "brew",
                "linux"
            ]
        },
        {
            "id": "https://haust-kevin.github.io/2023/08/15/2023-08-hello-world/",
            "url": "https://haust-kevin.github.io/2023/08/15/2023-08-hello-world/",
            "title": "Hello World",
            "date_published": "2023-08-15T08:48:34.000Z",
            "content_html": "<h1 id=\"欢迎\"><a class=\"anchor\" href=\"#欢迎\">#</a> 欢迎</h1>\n<p>大家好，欢迎来到我的个人博客 <span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwL2Jsb2cv\">沉思录</span>！我是 <strong>Kevin</strong>，一个热爱编程、追求技术创新的技术爱好者。通过这个博客，我希望能够与大家分享我的编程旅程、探索过程以及在技术领域的所见所闻。</p>\n<h1 id=\"追寻编程的脚步\"><a class=\"anchor\" href=\"#追寻编程的脚步\">#</a> 追寻编程的脚步</h1>\n<p>编程是一门既充满挑战又充满乐趣的艺术。从最初的 &quot;Hello World&quot; 到构建复杂的应用程序，每一行代码都是一次思考和创造的过程。我依然记得我第一次编写的程序，那种由错误到正确的过程，那种实现想法的成就感，都深深地吸引着我。</p>\n<h1 id=\"探索技术的前沿\"><a class=\"anchor\" href=\"#探索技术的前沿\">#</a> 探索技术的前沿</h1>\n<p>随着科技的迅猛发展，计算机技术也在不断刷新我们的认知。人工智能、区块链、云计算等领域的崭新概念不断涌现，我们仿佛站在了一个无限的技术边界前。在这个博客中，我将与大家一同探索这些前沿技术，分享我的学习经验和见解。</p>\n<h1 id=\"为何创建这个博客\"><a class=\"anchor\" href=\"#为何创建这个博客\">#</a> 为何创建这个博客</h1>\n<p>我创建这个博客的初衷是为了与大家分享我的技术探索、心得体会，同时也希望能够从您的反馈中学到更多。技术的道路上，我相信每个人都有独特的经验和见解，通过这个平台，我期待与您建立起一个互相学习、共同成长的社区。</p>\n<h1 id=\"展望未来\"><a class=\"anchor\" href=\"#展望未来\">#</a> 展望未来</h1>\n<p>在接下来的博客中，我将分享编程技巧、项目经验、技术思考等内容，同时也会关注技术界的热点和趋势，还会分享一些有趣的文章。我希望这个博客能够成为一个技术交流的场所，不仅仅是我与大家的沟通渠道，更是我们共同进步的平台。</p>\n<h1 id=\"结语\"><a class=\"anchor\" href=\"#结语\">#</a> 结语</h1>\n<p>感谢您花时间阅读我的第一篇博客。希望您能在今后的博客中找到对您有益的内容，也欢迎您留言分享您的想法和意见。让我们一起踏上这个编程之旅，探索计算机技术的无限魅力！</p>\n",
            "tags": []
        }
    ]
}